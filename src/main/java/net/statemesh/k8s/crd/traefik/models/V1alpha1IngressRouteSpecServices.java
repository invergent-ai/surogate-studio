/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.traefik.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import net.statemesh.k8s.crd.traefik.models.V1alpha1IngressRouteSpecHealthCheck;
import net.statemesh.k8s.crd.traefik.models.V1alpha1IngressRouteSpecResponseForwarding;
import net.statemesh.k8s.crd.traefik.models.V1alpha1IngressRouteSpecSticky;

/**
 * Service defines an upstream HTTP service to proxy traffic to.
 */
@ApiModel(description = "Service defines an upstream HTTP service to proxy traffic to.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-01-10T04:21:57.451Z[Etc/UTC]")
public class V1alpha1IngressRouteSpecServices {
  public static final String SERIALIZED_NAME_HEALTH_CHECK = "healthCheck";
  @SerializedName(SERIALIZED_NAME_HEALTH_CHECK)
  private V1alpha1IngressRouteSpecHealthCheck healthCheck;

  /**
   * Kind defines the kind of the Service.
   */
  @JsonAdapter(KindEnum.Adapter.class)
  public enum KindEnum {
    SERVICE("Service"),
    
    TRAEFIKSERVICE("TraefikService");

    private String value;

    KindEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static KindEnum fromValue(String value) {
      for (KindEnum b : KindEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<KindEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final KindEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public KindEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return KindEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_KIND = "kind";
  @SerializedName(SERIALIZED_NAME_KIND)
  private KindEnum kind;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_NATIVE_L_B = "nativeLB";
  @SerializedName(SERIALIZED_NAME_NATIVE_L_B)
  private Boolean nativeLB;

  public static final String SERIALIZED_NAME_NODE_PORT_L_B = "nodePortLB";
  @SerializedName(SERIALIZED_NAME_NODE_PORT_L_B)
  private Boolean nodePortLB;

  public static final String SERIALIZED_NAME_PASS_HOST_HEADER = "passHostHeader";
  @SerializedName(SERIALIZED_NAME_PASS_HOST_HEADER)
  private Boolean passHostHeader;

  public static final String SERIALIZED_NAME_PORT = "port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Object port;

  public static final String SERIALIZED_NAME_RESPONSE_FORWARDING = "responseForwarding";
  @SerializedName(SERIALIZED_NAME_RESPONSE_FORWARDING)
  private V1alpha1IngressRouteSpecResponseForwarding responseForwarding;

  public static final String SERIALIZED_NAME_SCHEME = "scheme";
  @SerializedName(SERIALIZED_NAME_SCHEME)
  private String scheme;

  public static final String SERIALIZED_NAME_SERVERS_TRANSPORT = "serversTransport";
  @SerializedName(SERIALIZED_NAME_SERVERS_TRANSPORT)
  private String serversTransport;

  public static final String SERIALIZED_NAME_STICKY = "sticky";
  @SerializedName(SERIALIZED_NAME_STICKY)
  private V1alpha1IngressRouteSpecSticky sticky;

  public static final String SERIALIZED_NAME_STRATEGY = "strategy";
  @SerializedName(SERIALIZED_NAME_STRATEGY)
  private String strategy;

  public static final String SERIALIZED_NAME_WEIGHT = "weight";
  @SerializedName(SERIALIZED_NAME_WEIGHT)
  private Integer weight;


  public V1alpha1IngressRouteSpecServices healthCheck(V1alpha1IngressRouteSpecHealthCheck healthCheck) {
    
    this.healthCheck = healthCheck;
    return this;
  }

   /**
   * Get healthCheck
   * @return healthCheck
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1IngressRouteSpecHealthCheck getHealthCheck() {
    return healthCheck;
  }


  public void setHealthCheck(V1alpha1IngressRouteSpecHealthCheck healthCheck) {
    this.healthCheck = healthCheck;
  }


  public V1alpha1IngressRouteSpecServices kind(KindEnum kind) {
    
    this.kind = kind;
    return this;
  }

   /**
   * Kind defines the kind of the Service.
   * @return kind
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Kind defines the kind of the Service.")

  public KindEnum getKind() {
    return kind;
  }


  public void setKind(KindEnum kind) {
    this.kind = kind;
  }


  public V1alpha1IngressRouteSpecServices name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Name defines the name of the referenced Kubernetes Service or TraefikService. The differentiation between the two is specified in the Kind field.
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Name defines the name of the referenced Kubernetes Service or TraefikService. The differentiation between the two is specified in the Kind field.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public V1alpha1IngressRouteSpecServices namespace(String namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
   * @return namespace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.")

  public String getNamespace() {
    return namespace;
  }


  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public V1alpha1IngressRouteSpecServices nativeLB(Boolean nativeLB) {
    
    this.nativeLB = nativeLB;
    return this;
  }

   /**
   * NativeLB controls, when creating the load-balancer, whether the LB&#39;s children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.
   * @return nativeLB
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "NativeLB controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.")

  public Boolean getNativeLB() {
    return nativeLB;
  }


  public void setNativeLB(Boolean nativeLB) {
    this.nativeLB = nativeLB;
  }


  public V1alpha1IngressRouteSpecServices nodePortLB(Boolean nodePortLB) {
    
    this.nodePortLB = nodePortLB;
    return this;
  }

   /**
   * NodePortLB controls, when creating the load-balancer, whether the LB&#39;s children are directly the nodes internal IPs using the nodePort when the service type is NodePort. It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes. By default, NodePortLB is false.
   * @return nodePortLB
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "NodePortLB controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort. It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes. By default, NodePortLB is false.")

  public Boolean getNodePortLB() {
    return nodePortLB;
  }


  public void setNodePortLB(Boolean nodePortLB) {
    this.nodePortLB = nodePortLB;
  }


  public V1alpha1IngressRouteSpecServices passHostHeader(Boolean passHostHeader) {
    
    this.passHostHeader = passHostHeader;
    return this;
  }

   /**
   * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service. By default, passHostHeader is true.
   * @return passHostHeader
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service. By default, passHostHeader is true.")

  public Boolean getPassHostHeader() {
    return passHostHeader;
  }


  public void setPassHostHeader(Boolean passHostHeader) {
    this.passHostHeader = passHostHeader;
  }


  public V1alpha1IngressRouteSpecServices port(Object port) {
    
    this.port = port;
    return this;
  }

   /**
   * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
   * @return port
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Port defines the port of a Kubernetes Service. This can be a reference to a named port.")

  public Object getPort() {
    return port;
  }


  public void setPort(Object port) {
    this.port = port;
  }


  public V1alpha1IngressRouteSpecServices responseForwarding(V1alpha1IngressRouteSpecResponseForwarding responseForwarding) {
    
    this.responseForwarding = responseForwarding;
    return this;
  }

   /**
   * Get responseForwarding
   * @return responseForwarding
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1IngressRouteSpecResponseForwarding getResponseForwarding() {
    return responseForwarding;
  }


  public void setResponseForwarding(V1alpha1IngressRouteSpecResponseForwarding responseForwarding) {
    this.responseForwarding = responseForwarding;
  }


  public V1alpha1IngressRouteSpecServices scheme(String scheme) {
    
    this.scheme = scheme;
    return this;
  }

   /**
   * Scheme defines the scheme to use for the request to the upstream Kubernetes Service. It defaults to https when Kubernetes Service port is 443, http otherwise.
   * @return scheme
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Scheme defines the scheme to use for the request to the upstream Kubernetes Service. It defaults to https when Kubernetes Service port is 443, http otherwise.")

  public String getScheme() {
    return scheme;
  }


  public void setScheme(String scheme) {
    this.scheme = scheme;
  }


  public V1alpha1IngressRouteSpecServices serversTransport(String serversTransport) {
    
    this.serversTransport = serversTransport;
    return this;
  }

   /**
   * ServersTransport defines the name of ServersTransport resource to use. It allows to configure the transport between Traefik and your servers. Can only be used on a Kubernetes Service.
   * @return serversTransport
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "ServersTransport defines the name of ServersTransport resource to use. It allows to configure the transport between Traefik and your servers. Can only be used on a Kubernetes Service.")

  public String getServersTransport() {
    return serversTransport;
  }


  public void setServersTransport(String serversTransport) {
    this.serversTransport = serversTransport;
  }


  public V1alpha1IngressRouteSpecServices sticky(V1alpha1IngressRouteSpecSticky sticky) {
    
    this.sticky = sticky;
    return this;
  }

   /**
   * Get sticky
   * @return sticky
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1IngressRouteSpecSticky getSticky() {
    return sticky;
  }


  public void setSticky(V1alpha1IngressRouteSpecSticky sticky) {
    this.sticky = sticky;
  }


  public V1alpha1IngressRouteSpecServices strategy(String strategy) {
    
    this.strategy = strategy;
    return this;
  }

   /**
   * Strategy defines the load balancing strategy between the servers. RoundRobin is the only supported value at the moment.
   * @return strategy
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Strategy defines the load balancing strategy between the servers. RoundRobin is the only supported value at the moment.")

  public String getStrategy() {
    return strategy;
  }


  public void setStrategy(String strategy) {
    this.strategy = strategy;
  }


  public V1alpha1IngressRouteSpecServices weight(Integer weight) {
    
    this.weight = weight;
    return this;
  }

   /**
   * Weight defines the weight and should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   * @return weight
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Weight defines the weight and should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).")

  public Integer getWeight() {
    return weight;
  }


  public void setWeight(Integer weight) {
    this.weight = weight;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1IngressRouteSpecServices v1alpha1IngressRouteSpecServices = (V1alpha1IngressRouteSpecServices) o;
    return Objects.equals(this.healthCheck, v1alpha1IngressRouteSpecServices.healthCheck) &&
        Objects.equals(this.kind, v1alpha1IngressRouteSpecServices.kind) &&
        Objects.equals(this.name, v1alpha1IngressRouteSpecServices.name) &&
        Objects.equals(this.namespace, v1alpha1IngressRouteSpecServices.namespace) &&
        Objects.equals(this.nativeLB, v1alpha1IngressRouteSpecServices.nativeLB) &&
        Objects.equals(this.nodePortLB, v1alpha1IngressRouteSpecServices.nodePortLB) &&
        Objects.equals(this.passHostHeader, v1alpha1IngressRouteSpecServices.passHostHeader) &&
        Objects.equals(this.port, v1alpha1IngressRouteSpecServices.port) &&
        Objects.equals(this.responseForwarding, v1alpha1IngressRouteSpecServices.responseForwarding) &&
        Objects.equals(this.scheme, v1alpha1IngressRouteSpecServices.scheme) &&
        Objects.equals(this.serversTransport, v1alpha1IngressRouteSpecServices.serversTransport) &&
        Objects.equals(this.sticky, v1alpha1IngressRouteSpecServices.sticky) &&
        Objects.equals(this.strategy, v1alpha1IngressRouteSpecServices.strategy) &&
        Objects.equals(this.weight, v1alpha1IngressRouteSpecServices.weight);
  }

  @Override
  public int hashCode() {
    return Objects.hash(healthCheck, kind, name, namespace, nativeLB, nodePortLB, passHostHeader, port, responseForwarding, scheme, serversTransport, sticky, strategy, weight);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1IngressRouteSpecServices {\n");
    sb.append("    healthCheck: ").append(toIndentedString(healthCheck)).append("\n");
    sb.append("    kind: ").append(toIndentedString(kind)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    nativeLB: ").append(toIndentedString(nativeLB)).append("\n");
    sb.append("    nodePortLB: ").append(toIndentedString(nodePortLB)).append("\n");
    sb.append("    passHostHeader: ").append(toIndentedString(passHostHeader)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    responseForwarding: ").append(toIndentedString(responseForwarding)).append("\n");
    sb.append("    scheme: ").append(toIndentedString(scheme)).append("\n");
    sb.append("    serversTransport: ").append(toIndentedString(serversTransport)).append("\n");
    sb.append("    sticky: ").append(toIndentedString(sticky)).append("\n");
    sb.append("    strategy: ").append(toIndentedString(strategy)).append("\n");
    sb.append("    weight: ").append(toIndentedString(weight)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}


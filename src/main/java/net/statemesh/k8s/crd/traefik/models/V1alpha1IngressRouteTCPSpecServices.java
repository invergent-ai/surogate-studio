/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.traefik.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import net.statemesh.k8s.crd.traefik.models.V1alpha1IngressRouteTCPSpecProxyProtocol;

/**
 * ServiceTCP defines an upstream TCP service to proxy traffic to.
 */
@ApiModel(description = "ServiceTCP defines an upstream TCP service to proxy traffic to.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-01-10T04:21:57.451Z[Etc/UTC]")
public class V1alpha1IngressRouteTCPSpecServices {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_NATIVE_L_B = "nativeLB";
  @SerializedName(SERIALIZED_NAME_NATIVE_L_B)
  private Boolean nativeLB;

  public static final String SERIALIZED_NAME_NODE_PORT_L_B = "nodePortLB";
  @SerializedName(SERIALIZED_NAME_NODE_PORT_L_B)
  private Boolean nodePortLB;

  public static final String SERIALIZED_NAME_PORT = "port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Object port;

  public static final String SERIALIZED_NAME_PROXY_PROTOCOL = "proxyProtocol";
  @SerializedName(SERIALIZED_NAME_PROXY_PROTOCOL)
  private V1alpha1IngressRouteTCPSpecProxyProtocol proxyProtocol;

  public static final String SERIALIZED_NAME_SERVERS_TRANSPORT = "serversTransport";
  @SerializedName(SERIALIZED_NAME_SERVERS_TRANSPORT)
  private String serversTransport;

  public static final String SERIALIZED_NAME_TERMINATION_DELAY = "terminationDelay";
  @SerializedName(SERIALIZED_NAME_TERMINATION_DELAY)
  private Integer terminationDelay;

  public static final String SERIALIZED_NAME_TLS = "tls";
  @SerializedName(SERIALIZED_NAME_TLS)
  private Boolean tls;

  public static final String SERIALIZED_NAME_WEIGHT = "weight";
  @SerializedName(SERIALIZED_NAME_WEIGHT)
  private Integer weight;


  public V1alpha1IngressRouteTCPSpecServices name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Name defines the name of the referenced Kubernetes Service.
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Name defines the name of the referenced Kubernetes Service.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public V1alpha1IngressRouteTCPSpecServices namespace(String namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * Namespace defines the namespace of the referenced Kubernetes Service.
   * @return namespace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Namespace defines the namespace of the referenced Kubernetes Service.")

  public String getNamespace() {
    return namespace;
  }


  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public V1alpha1IngressRouteTCPSpecServices nativeLB(Boolean nativeLB) {
    
    this.nativeLB = nativeLB;
    return this;
  }

   /**
   * NativeLB controls, when creating the load-balancer, whether the LB&#39;s children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.
   * @return nativeLB
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "NativeLB controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.")

  public Boolean getNativeLB() {
    return nativeLB;
  }


  public void setNativeLB(Boolean nativeLB) {
    this.nativeLB = nativeLB;
  }


  public V1alpha1IngressRouteTCPSpecServices nodePortLB(Boolean nodePortLB) {
    
    this.nodePortLB = nodePortLB;
    return this;
  }

   /**
   * NodePortLB controls, when creating the load-balancer, whether the LB&#39;s children are directly the nodes internal IPs using the nodePort when the service type is NodePort. It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes. By default, NodePortLB is false.
   * @return nodePortLB
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "NodePortLB controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort. It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes. By default, NodePortLB is false.")

  public Boolean getNodePortLB() {
    return nodePortLB;
  }


  public void setNodePortLB(Boolean nodePortLB) {
    this.nodePortLB = nodePortLB;
  }


  public V1alpha1IngressRouteTCPSpecServices port(Object port) {
    
    this.port = port;
    return this;
  }

   /**
   * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
   * @return port
  **/
  @ApiModelProperty(required = true, value = "Port defines the port of a Kubernetes Service. This can be a reference to a named port.")

  public Object getPort() {
    return port;
  }


  public void setPort(Object port) {
    this.port = port;
  }


  public V1alpha1IngressRouteTCPSpecServices proxyProtocol(V1alpha1IngressRouteTCPSpecProxyProtocol proxyProtocol) {
    
    this.proxyProtocol = proxyProtocol;
    return this;
  }

   /**
   * Get proxyProtocol
   * @return proxyProtocol
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public V1alpha1IngressRouteTCPSpecProxyProtocol getProxyProtocol() {
    return proxyProtocol;
  }


  public void setProxyProtocol(V1alpha1IngressRouteTCPSpecProxyProtocol proxyProtocol) {
    this.proxyProtocol = proxyProtocol;
  }


  public V1alpha1IngressRouteTCPSpecServices serversTransport(String serversTransport) {
    
    this.serversTransport = serversTransport;
    return this;
  }

   /**
   * ServersTransport defines the name of ServersTransportTCP resource to use. It allows to configure the transport between Traefik and your servers. Can only be used on a Kubernetes Service.
   * @return serversTransport
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "ServersTransport defines the name of ServersTransportTCP resource to use. It allows to configure the transport between Traefik and your servers. Can only be used on a Kubernetes Service.")

  public String getServersTransport() {
    return serversTransport;
  }


  public void setServersTransport(String serversTransport) {
    this.serversTransport = serversTransport;
  }


  public V1alpha1IngressRouteTCPSpecServices terminationDelay(Integer terminationDelay) {
    
    this.terminationDelay = terminationDelay;
    return this;
  }

   /**
   * TerminationDelay defines the deadline that the proxy sets, after one of its connected peers indicates it has closed the writing capability of its connection, to close the reading capability as well, hence fully terminating the connection. It is a duration in milliseconds, defaulting to 100. A negative value means an infinite deadline (i.e. the reading capability is never closed). Deprecated: TerminationDelay will not be supported in future APIVersions, please use ServersTransport to configure the TerminationDelay instead.
   * @return terminationDelay
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "TerminationDelay defines the deadline that the proxy sets, after one of its connected peers indicates it has closed the writing capability of its connection, to close the reading capability as well, hence fully terminating the connection. It is a duration in milliseconds, defaulting to 100. A negative value means an infinite deadline (i.e. the reading capability is never closed). Deprecated: TerminationDelay will not be supported in future APIVersions, please use ServersTransport to configure the TerminationDelay instead.")

  public Integer getTerminationDelay() {
    return terminationDelay;
  }


  public void setTerminationDelay(Integer terminationDelay) {
    this.terminationDelay = terminationDelay;
  }


  public V1alpha1IngressRouteTCPSpecServices tls(Boolean tls) {
    
    this.tls = tls;
    return this;
  }

   /**
   * TLS determines whether to use TLS when dialing with the backend.
   * @return tls
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "TLS determines whether to use TLS when dialing with the backend.")

  public Boolean getTls() {
    return tls;
  }


  public void setTls(Boolean tls) {
    this.tls = tls;
  }


  public V1alpha1IngressRouteTCPSpecServices weight(Integer weight) {
    
    this.weight = weight;
    return this;
  }

   /**
   * Weight defines the weight used when balancing requests between multiple Kubernetes Service.
   * @return weight
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Weight defines the weight used when balancing requests between multiple Kubernetes Service.")

  public Integer getWeight() {
    return weight;
  }


  public void setWeight(Integer weight) {
    this.weight = weight;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1IngressRouteTCPSpecServices v1alpha1IngressRouteTCPSpecServices = (V1alpha1IngressRouteTCPSpecServices) o;
    return Objects.equals(this.name, v1alpha1IngressRouteTCPSpecServices.name) &&
        Objects.equals(this.namespace, v1alpha1IngressRouteTCPSpecServices.namespace) &&
        Objects.equals(this.nativeLB, v1alpha1IngressRouteTCPSpecServices.nativeLB) &&
        Objects.equals(this.nodePortLB, v1alpha1IngressRouteTCPSpecServices.nodePortLB) &&
        Objects.equals(this.port, v1alpha1IngressRouteTCPSpecServices.port) &&
        Objects.equals(this.proxyProtocol, v1alpha1IngressRouteTCPSpecServices.proxyProtocol) &&
        Objects.equals(this.serversTransport, v1alpha1IngressRouteTCPSpecServices.serversTransport) &&
        Objects.equals(this.terminationDelay, v1alpha1IngressRouteTCPSpecServices.terminationDelay) &&
        Objects.equals(this.tls, v1alpha1IngressRouteTCPSpecServices.tls) &&
        Objects.equals(this.weight, v1alpha1IngressRouteTCPSpecServices.weight);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, namespace, nativeLB, nodePortLB, port, proxyProtocol, serversTransport, terminationDelay, tls, weight);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1IngressRouteTCPSpecServices {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    nativeLB: ").append(toIndentedString(nativeLB)).append("\n");
    sb.append("    nodePortLB: ").append(toIndentedString(nodePortLB)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    proxyProtocol: ").append(toIndentedString(proxyProtocol)).append("\n");
    sb.append("    serversTransport: ").append(toIndentedString(serversTransport)).append("\n");
    sb.append("    terminationDelay: ").append(toIndentedString(terminationDelay)).append("\n");
    sb.append("    tls: ").append(toIndentedString(tls)).append("\n");
    sb.append("    weight: ").append(toIndentedString(weight)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}


/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.traefik.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * ServiceUDP defines an upstream UDP service to proxy traffic to.
 */
@ApiModel(description = "ServiceUDP defines an upstream UDP service to proxy traffic to.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-01-10T04:21:57.451Z[Etc/UTC]")
public class V1alpha1IngressRouteUDPSpecServices {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_NAMESPACE = "namespace";
  @SerializedName(SERIALIZED_NAME_NAMESPACE)
  private String namespace;

  public static final String SERIALIZED_NAME_NATIVE_L_B = "nativeLB";
  @SerializedName(SERIALIZED_NAME_NATIVE_L_B)
  private Boolean nativeLB;

  public static final String SERIALIZED_NAME_NODE_PORT_L_B = "nodePortLB";
  @SerializedName(SERIALIZED_NAME_NODE_PORT_L_B)
  private Boolean nodePortLB;

  public static final String SERIALIZED_NAME_PORT = "port";
  @SerializedName(SERIALIZED_NAME_PORT)
  private Object port;

  public static final String SERIALIZED_NAME_WEIGHT = "weight";
  @SerializedName(SERIALIZED_NAME_WEIGHT)
  private Integer weight;


  public V1alpha1IngressRouteUDPSpecServices name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Name defines the name of the referenced Kubernetes Service.
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Name defines the name of the referenced Kubernetes Service.")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public V1alpha1IngressRouteUDPSpecServices namespace(String namespace) {
    
    this.namespace = namespace;
    return this;
  }

   /**
   * Namespace defines the namespace of the referenced Kubernetes Service.
   * @return namespace
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Namespace defines the namespace of the referenced Kubernetes Service.")

  public String getNamespace() {
    return namespace;
  }


  public void setNamespace(String namespace) {
    this.namespace = namespace;
  }


  public V1alpha1IngressRouteUDPSpecServices nativeLB(Boolean nativeLB) {
    
    this.nativeLB = nativeLB;
    return this;
  }

   /**
   * NativeLB controls, when creating the load-balancer, whether the LB&#39;s children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.
   * @return nativeLB
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "NativeLB controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.")

  public Boolean getNativeLB() {
    return nativeLB;
  }


  public void setNativeLB(Boolean nativeLB) {
    this.nativeLB = nativeLB;
  }


  public V1alpha1IngressRouteUDPSpecServices nodePortLB(Boolean nodePortLB) {
    
    this.nodePortLB = nodePortLB;
    return this;
  }

   /**
   * NodePortLB controls, when creating the load-balancer, whether the LB&#39;s children are directly the nodes internal IPs using the nodePort when the service type is NodePort. It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes. By default, NodePortLB is false.
   * @return nodePortLB
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "NodePortLB controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort. It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes. By default, NodePortLB is false.")

  public Boolean getNodePortLB() {
    return nodePortLB;
  }


  public void setNodePortLB(Boolean nodePortLB) {
    this.nodePortLB = nodePortLB;
  }


  public V1alpha1IngressRouteUDPSpecServices port(Object port) {
    
    this.port = port;
    return this;
  }

   /**
   * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
   * @return port
  **/
  @ApiModelProperty(required = true, value = "Port defines the port of a Kubernetes Service. This can be a reference to a named port.")

  public Object getPort() {
    return port;
  }


  public void setPort(Object port) {
    this.port = port;
  }


  public V1alpha1IngressRouteUDPSpecServices weight(Integer weight) {
    
    this.weight = weight;
    return this;
  }

   /**
   * Weight defines the weight used when balancing requests between multiple Kubernetes Service.
   * @return weight
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Weight defines the weight used when balancing requests between multiple Kubernetes Service.")

  public Integer getWeight() {
    return weight;
  }


  public void setWeight(Integer weight) {
    this.weight = weight;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1IngressRouteUDPSpecServices v1alpha1IngressRouteUDPSpecServices = (V1alpha1IngressRouteUDPSpecServices) o;
    return Objects.equals(this.name, v1alpha1IngressRouteUDPSpecServices.name) &&
        Objects.equals(this.namespace, v1alpha1IngressRouteUDPSpecServices.namespace) &&
        Objects.equals(this.nativeLB, v1alpha1IngressRouteUDPSpecServices.nativeLB) &&
        Objects.equals(this.nodePortLB, v1alpha1IngressRouteUDPSpecServices.nodePortLB) &&
        Objects.equals(this.port, v1alpha1IngressRouteUDPSpecServices.port) &&
        Objects.equals(this.weight, v1alpha1IngressRouteUDPSpecServices.weight);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, namespace, nativeLB, nodePortLB, port, weight);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1IngressRouteUDPSpecServices {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    namespace: ").append(toIndentedString(namespace)).append("\n");
    sb.append("    nativeLB: ").append(toIndentedString(nativeLB)).append("\n");
    sb.append("    nodePortLB: ").append(toIndentedString(nodePortLB)).append("\n");
    sb.append("    port: ").append(toIndentedString(port)).append("\n");
    sb.append("    weight: ").append(toIndentedString(weight)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}


/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.tekton.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusChildReferencesInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusConditionsInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusProvenance;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusResultsInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusSkippedTasksInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * PipelineRunStatus defines the observed state of PipelineRun
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-10-01T09:42:24.724862Z[Etc/UTC]")
public class V1PipelineRunStatus {
  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private Map<String, String> annotations = new HashMap<>();

  public static final String SERIALIZED_NAME_CHILD_REFERENCES = "childReferences";
  @SerializedName(SERIALIZED_NAME_CHILD_REFERENCES)
  private List<V1PipelineRunStatusChildReferencesInner> childReferences;

  public static final String SERIALIZED_NAME_COMPLETION_TIME = "completionTime";
  @SerializedName(SERIALIZED_NAME_COMPLETION_TIME)
  private OffsetDateTime completionTime;

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private List<V1PipelineRunStatusConditionsInner> conditions;

  public static final String SERIALIZED_NAME_FINALLY_START_TIME = "finallyStartTime";
  @SerializedName(SERIALIZED_NAME_FINALLY_START_TIME)
  private OffsetDateTime finallyStartTime;

  public static final String SERIALIZED_NAME_OBSERVED_GENERATION = "observedGeneration";
  @SerializedName(SERIALIZED_NAME_OBSERVED_GENERATION)
  private Long observedGeneration;

  public static final String SERIALIZED_NAME_PIPELINE_SPEC = "pipelineSpec";
  @SerializedName(SERIALIZED_NAME_PIPELINE_SPEC)
  private Object pipelineSpec;

  public static final String SERIALIZED_NAME_PROVENANCE = "provenance";
  @SerializedName(SERIALIZED_NAME_PROVENANCE)
  private V1PipelineRunStatusProvenance provenance;

  public static final String SERIALIZED_NAME_RESULTS = "results";
  @SerializedName(SERIALIZED_NAME_RESULTS)
  private List<V1PipelineRunStatusResultsInner> results;

  public static final String SERIALIZED_NAME_SKIPPED_TASKS = "skippedTasks";
  @SerializedName(SERIALIZED_NAME_SKIPPED_TASKS)
  private List<V1PipelineRunStatusSkippedTasksInner> skippedTasks;

  public static final String SERIALIZED_NAME_SPAN_CONTEXT = "spanContext";
  @SerializedName(SERIALIZED_NAME_SPAN_CONTEXT)
  private Map<String, String> spanContext = new HashMap<>();

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private OffsetDateTime startTime;

  public V1PipelineRunStatus() {
  }

  public V1PipelineRunStatus annotations(Map<String, String> annotations) {
    
    this.annotations = annotations;
    return this;
  }

  public V1PipelineRunStatus putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

   /**
   * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
   * @return annotations
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getAnnotations() {
    return annotations;
  }


  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }


  public V1PipelineRunStatus childReferences(List<V1PipelineRunStatusChildReferencesInner> childReferences) {
    
    this.childReferences = childReferences;
    return this;
  }

  public V1PipelineRunStatus addChildReferencesItem(V1PipelineRunStatusChildReferencesInner childReferencesItem) {
    if (this.childReferences == null) {
      this.childReferences = new ArrayList<>();
    }
    this.childReferences.add(childReferencesItem);
    return this;
  }

   /**
   * list of TaskRun and Run names, PipelineTask names, and API versions/kinds for children of this PipelineRun.
   * @return childReferences
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusChildReferencesInner> getChildReferences() {
    return childReferences;
  }


  public void setChildReferences(List<V1PipelineRunStatusChildReferencesInner> childReferences) {
    this.childReferences = childReferences;
  }


  public V1PipelineRunStatus completionTime(OffsetDateTime completionTime) {
    
    this.completionTime = completionTime;
    return this;
  }

   /**
   * CompletionTime is the time the PipelineRun completed.
   * @return completionTime
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getCompletionTime() {
    return completionTime;
  }


  public void setCompletionTime(OffsetDateTime completionTime) {
    this.completionTime = completionTime;
  }


  public V1PipelineRunStatus conditions(List<V1PipelineRunStatusConditionsInner> conditions) {
    
    this.conditions = conditions;
    return this;
  }

  public V1PipelineRunStatus addConditionsItem(V1PipelineRunStatusConditionsInner conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * Conditions the latest available observations of a resource&#39;s current state.
   * @return conditions
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusConditionsInner> getConditions() {
    return conditions;
  }


  public void setConditions(List<V1PipelineRunStatusConditionsInner> conditions) {
    this.conditions = conditions;
  }


  public V1PipelineRunStatus finallyStartTime(OffsetDateTime finallyStartTime) {
    
    this.finallyStartTime = finallyStartTime;
    return this;
  }

   /**
   * FinallyStartTime is when all non-finally tasks have been completed and only finally tasks are being executed.
   * @return finallyStartTime
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getFinallyStartTime() {
    return finallyStartTime;
  }


  public void setFinallyStartTime(OffsetDateTime finallyStartTime) {
    this.finallyStartTime = finallyStartTime;
  }


  public V1PipelineRunStatus observedGeneration(Long observedGeneration) {
    
    this.observedGeneration = observedGeneration;
    return this;
  }

   /**
   * ObservedGeneration is the &#39;Generation&#39; of the Service that was last processed by the controller.
   * @return observedGeneration
  **/
  @jakarta.annotation.Nullable
  public Long getObservedGeneration() {
    return observedGeneration;
  }


  public void setObservedGeneration(Long observedGeneration) {
    this.observedGeneration = observedGeneration;
  }


  public V1PipelineRunStatus pipelineSpec(Object pipelineSpec) {
    
    this.pipelineSpec = pipelineSpec;
    return this;
  }

   /**
   * PipelineSpec contains the exact spec used to instantiate the run. See Pipeline.spec (API version: tekton.dev/v1)
   * @return pipelineSpec
  **/
  @jakarta.annotation.Nullable
  public Object getPipelineSpec() {
    return pipelineSpec;
  }


  public void setPipelineSpec(Object pipelineSpec) {
    this.pipelineSpec = pipelineSpec;
  }


  public V1PipelineRunStatus provenance(V1PipelineRunStatusProvenance provenance) {
    
    this.provenance = provenance;
    return this;
  }

   /**
   * Get provenance
   * @return provenance
  **/
  @jakarta.annotation.Nullable
  public V1PipelineRunStatusProvenance getProvenance() {
    return provenance;
  }


  public void setProvenance(V1PipelineRunStatusProvenance provenance) {
    this.provenance = provenance;
  }


  public V1PipelineRunStatus results(List<V1PipelineRunStatusResultsInner> results) {
    
    this.results = results;
    return this;
  }

  public V1PipelineRunStatus addResultsItem(V1PipelineRunStatusResultsInner resultsItem) {
    if (this.results == null) {
      this.results = new ArrayList<>();
    }
    this.results.add(resultsItem);
    return this;
  }

   /**
   * Results are the list of results written out by the pipeline task&#39;s containers
   * @return results
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusResultsInner> getResults() {
    return results;
  }


  public void setResults(List<V1PipelineRunStatusResultsInner> results) {
    this.results = results;
  }


  public V1PipelineRunStatus skippedTasks(List<V1PipelineRunStatusSkippedTasksInner> skippedTasks) {
    
    this.skippedTasks = skippedTasks;
    return this;
  }

  public V1PipelineRunStatus addSkippedTasksItem(V1PipelineRunStatusSkippedTasksInner skippedTasksItem) {
    if (this.skippedTasks == null) {
      this.skippedTasks = new ArrayList<>();
    }
    this.skippedTasks.add(skippedTasksItem);
    return this;
  }

   /**
   * list of tasks that were skipped due to when expressions evaluating to false
   * @return skippedTasks
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusSkippedTasksInner> getSkippedTasks() {
    return skippedTasks;
  }


  public void setSkippedTasks(List<V1PipelineRunStatusSkippedTasksInner> skippedTasks) {
    this.skippedTasks = skippedTasks;
  }


  public V1PipelineRunStatus spanContext(Map<String, String> spanContext) {
    
    this.spanContext = spanContext;
    return this;
  }

  public V1PipelineRunStatus putSpanContextItem(String key, String spanContextItem) {
    if (this.spanContext == null) {
      this.spanContext = new HashMap<>();
    }
    this.spanContext.put(key, spanContextItem);
    return this;
  }

   /**
   * SpanContext contains tracing span context fields
   * @return spanContext
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getSpanContext() {
    return spanContext;
  }


  public void setSpanContext(Map<String, String> spanContext) {
    this.spanContext = spanContext;
  }


  public V1PipelineRunStatus startTime(OffsetDateTime startTime) {
    
    this.startTime = startTime;
    return this;
  }

   /**
   * StartTime is the time the PipelineRun is actually started.
   * @return startTime
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getStartTime() {
    return startTime;
  }


  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = startTime;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1PipelineRunStatus v1PipelineRunStatus = (V1PipelineRunStatus) o;
    return Objects.equals(this.annotations, v1PipelineRunStatus.annotations) &&
        Objects.equals(this.childReferences, v1PipelineRunStatus.childReferences) &&
        Objects.equals(this.completionTime, v1PipelineRunStatus.completionTime) &&
        Objects.equals(this.conditions, v1PipelineRunStatus.conditions) &&
        Objects.equals(this.finallyStartTime, v1PipelineRunStatus.finallyStartTime) &&
        Objects.equals(this.observedGeneration, v1PipelineRunStatus.observedGeneration) &&
        Objects.equals(this.pipelineSpec, v1PipelineRunStatus.pipelineSpec) &&
        Objects.equals(this.provenance, v1PipelineRunStatus.provenance) &&
        Objects.equals(this.results, v1PipelineRunStatus.results) &&
        Objects.equals(this.skippedTasks, v1PipelineRunStatus.skippedTasks) &&
        Objects.equals(this.spanContext, v1PipelineRunStatus.spanContext) &&
        Objects.equals(this.startTime, v1PipelineRunStatus.startTime);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotations, childReferences, completionTime, conditions, finallyStartTime, observedGeneration, pipelineSpec, provenance, results, skippedTasks, spanContext, startTime);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1PipelineRunStatus {\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    childReferences: ").append(toIndentedString(childReferences)).append("\n");
    sb.append("    completionTime: ").append(toIndentedString(completionTime)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    finallyStartTime: ").append(toIndentedString(finallyStartTime)).append("\n");
    sb.append("    observedGeneration: ").append(toIndentedString(observedGeneration)).append("\n");
    sb.append("    pipelineSpec: ").append(toIndentedString(pipelineSpec)).append("\n");
    sb.append("    provenance: ").append(toIndentedString(provenance)).append("\n");
    sb.append("    results: ").append(toIndentedString(results)).append("\n");
    sb.append("    skippedTasks: ").append(toIndentedString(skippedTasks)).append("\n");
    sb.append("    spanContext: ").append(toIndentedString(spanContext)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotations");
    openapiFields.add("childReferences");
    openapiFields.add("completionTime");
    openapiFields.add("conditions");
    openapiFields.add("finallyStartTime");
    openapiFields.add("observedGeneration");
    openapiFields.add("pipelineSpec");
    openapiFields.add("provenance");
    openapiFields.add("results");
    openapiFields.add("skippedTasks");
    openapiFields.add("spanContext");
    openapiFields.add("startTime");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1PipelineRunStatus
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1PipelineRunStatus.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1PipelineRunStatus is not found in the empty JSON string", V1PipelineRunStatus.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1PipelineRunStatus.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1PipelineRunStatus` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if (jsonObj.get("childReferences") != null && !jsonObj.get("childReferences").isJsonNull()) {
        JsonArray jsonArraychildReferences = jsonObj.getAsJsonArray("childReferences");
        if (jsonArraychildReferences != null) {
          // ensure the json data is an array
          if (!jsonObj.get("childReferences").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `childReferences` to be an array in the JSON string but got `%s`", jsonObj.get("childReferences").toString()));
          }

          // validate the optional field `childReferences` (array)
          for (int i = 0; i < jsonArraychildReferences.size(); i++) {
            V1PipelineRunStatusChildReferencesInner.validateJsonObject(jsonArraychildReferences.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("conditions") != null && !jsonObj.get("conditions").isJsonNull()) {
        JsonArray jsonArrayconditions = jsonObj.getAsJsonArray("conditions");
        if (jsonArrayconditions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("conditions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `conditions` to be an array in the JSON string but got `%s`", jsonObj.get("conditions").toString()));
          }

          // validate the optional field `conditions` (array)
          for (int i = 0; i < jsonArrayconditions.size(); i++) {
            V1PipelineRunStatusConditionsInner.validateJsonObject(jsonArrayconditions.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `provenance`
      if (jsonObj.get("provenance") != null && !jsonObj.get("provenance").isJsonNull()) {
        V1PipelineRunStatusProvenance.validateJsonObject(jsonObj.getAsJsonObject("provenance"));
      }
      if (jsonObj.get("results") != null && !jsonObj.get("results").isJsonNull()) {
        JsonArray jsonArrayresults = jsonObj.getAsJsonArray("results");
        if (jsonArrayresults != null) {
          // ensure the json data is an array
          if (!jsonObj.get("results").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `results` to be an array in the JSON string but got `%s`", jsonObj.get("results").toString()));
          }

          // validate the optional field `results` (array)
          for (int i = 0; i < jsonArrayresults.size(); i++) {
            V1PipelineRunStatusResultsInner.validateJsonObject(jsonArrayresults.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("skippedTasks") != null && !jsonObj.get("skippedTasks").isJsonNull()) {
        JsonArray jsonArrayskippedTasks = jsonObj.getAsJsonArray("skippedTasks");
        if (jsonArrayskippedTasks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("skippedTasks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `skippedTasks` to be an array in the JSON string but got `%s`", jsonObj.get("skippedTasks").toString()));
          }

          // validate the optional field `skippedTasks` (array)
          for (int i = 0; i < jsonArrayskippedTasks.size(); i++) {
            V1PipelineRunStatusSkippedTasksInner.validateJsonObject(jsonArrayskippedTasks.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1PipelineRunStatus.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1PipelineRunStatus' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1PipelineRunStatus> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1PipelineRunStatus.class));

       return (TypeAdapter<T>) new TypeAdapter<V1PipelineRunStatus>() {
           @Override
           public void write(JsonWriter out, V1PipelineRunStatus value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1PipelineRunStatus read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1PipelineRunStatus given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1PipelineRunStatus
  * @throws IOException if the JSON string is invalid with respect to V1PipelineRunStatus
  */
  public static V1PipelineRunStatus fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1PipelineRunStatus.class);
  }

 /**
  * Convert an instance of V1PipelineRunStatus to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


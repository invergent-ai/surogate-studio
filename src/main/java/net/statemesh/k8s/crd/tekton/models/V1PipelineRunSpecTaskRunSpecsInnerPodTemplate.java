/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.tekton.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunSpecTaskRunSpecsInnerPodTemplateDnsConfig;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunSpecTaskRunSpecsInnerPodTemplateEnvInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunSpecTaskRunSpecsInnerPodTemplateHostAliasesInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunSpecTaskRunSpecsInnerPodTemplateImagePullSecretsInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTolerationsInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTopologySpreadConstraintsInner;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * PodTemplate holds pod specific configuration
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-10-01T09:42:24.724862Z[Etc/UTC]")
public class V1PipelineRunSpecTaskRunSpecsInnerPodTemplate {
  public static final String SERIALIZED_NAME_AFFINITY = "affinity";
  @SerializedName(SERIALIZED_NAME_AFFINITY)
  private Object affinity;

  public static final String SERIALIZED_NAME_AUTOMOUNT_SERVICE_ACCOUNT_TOKEN = "automountServiceAccountToken";
  @SerializedName(SERIALIZED_NAME_AUTOMOUNT_SERVICE_ACCOUNT_TOKEN)
  private Boolean automountServiceAccountToken;

  public static final String SERIALIZED_NAME_DNS_CONFIG = "dnsConfig";
  @SerializedName(SERIALIZED_NAME_DNS_CONFIG)
  private V1PipelineRunSpecTaskRunSpecsInnerPodTemplateDnsConfig dnsConfig;

  public static final String SERIALIZED_NAME_DNS_POLICY = "dnsPolicy";
  @SerializedName(SERIALIZED_NAME_DNS_POLICY)
  private String dnsPolicy;

  public static final String SERIALIZED_NAME_ENABLE_SERVICE_LINKS = "enableServiceLinks";
  @SerializedName(SERIALIZED_NAME_ENABLE_SERVICE_LINKS)
  private Boolean enableServiceLinks;

  public static final String SERIALIZED_NAME_ENV = "env";
  @SerializedName(SERIALIZED_NAME_ENV)
  private List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateEnvInner> env;

  public static final String SERIALIZED_NAME_HOST_ALIASES = "hostAliases";
  @SerializedName(SERIALIZED_NAME_HOST_ALIASES)
  private List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateHostAliasesInner> hostAliases;

  public static final String SERIALIZED_NAME_HOST_NETWORK = "hostNetwork";
  @SerializedName(SERIALIZED_NAME_HOST_NETWORK)
  private Boolean hostNetwork;

  public static final String SERIALIZED_NAME_IMAGE_PULL_SECRETS = "imagePullSecrets";
  @SerializedName(SERIALIZED_NAME_IMAGE_PULL_SECRETS)
  private List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateImagePullSecretsInner> imagePullSecrets;

  public static final String SERIALIZED_NAME_NODE_SELECTOR = "nodeSelector";
  @SerializedName(SERIALIZED_NAME_NODE_SELECTOR)
  private Map<String, String> nodeSelector = new HashMap<>();

  public static final String SERIALIZED_NAME_PRIORITY_CLASS_NAME = "priorityClassName";
  @SerializedName(SERIALIZED_NAME_PRIORITY_CLASS_NAME)
  private String priorityClassName;

  public static final String SERIALIZED_NAME_RUNTIME_CLASS_NAME = "runtimeClassName";
  @SerializedName(SERIALIZED_NAME_RUNTIME_CLASS_NAME)
  private String runtimeClassName;

  public static final String SERIALIZED_NAME_SCHEDULER_NAME = "schedulerName";
  @SerializedName(SERIALIZED_NAME_SCHEDULER_NAME)
  private String schedulerName;

  public static final String SERIALIZED_NAME_SECURITY_CONTEXT = "securityContext";
  @SerializedName(SERIALIZED_NAME_SECURITY_CONTEXT)
  private Object securityContext;

  public static final String SERIALIZED_NAME_TOLERATIONS = "tolerations";
  @SerializedName(SERIALIZED_NAME_TOLERATIONS)
  private List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTolerationsInner> tolerations;

  public static final String SERIALIZED_NAME_TOPOLOGY_SPREAD_CONSTRAINTS = "topologySpreadConstraints";
  @SerializedName(SERIALIZED_NAME_TOPOLOGY_SPREAD_CONSTRAINTS)
  private List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTopologySpreadConstraintsInner> topologySpreadConstraints;

  public static final String SERIALIZED_NAME_VOLUMES = "volumes";
  @SerializedName(SERIALIZED_NAME_VOLUMES)
  private Object volumes;

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate() {
  }

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate affinity(Object affinity) {
    
    this.affinity = affinity;
    return this;
  }

   /**
   * If specified, the pod&#39;s scheduling constraints. See Pod.spec.affinity (API version: v1)
   * @return affinity
  **/
  @jakarta.annotation.Nullable
  public Object getAffinity() {
    return affinity;
  }


  public void setAffinity(Object affinity) {
    this.affinity = affinity;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate automountServiceAccountToken(Boolean automountServiceAccountToken) {
    
    this.automountServiceAccountToken = automountServiceAccountToken;
    return this;
  }

   /**
   * AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
   * @return automountServiceAccountToken
  **/
  @jakarta.annotation.Nullable
  public Boolean getAutomountServiceAccountToken() {
    return automountServiceAccountToken;
  }


  public void setAutomountServiceAccountToken(Boolean automountServiceAccountToken) {
    this.automountServiceAccountToken = automountServiceAccountToken;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate dnsConfig(V1PipelineRunSpecTaskRunSpecsInnerPodTemplateDnsConfig dnsConfig) {
    
    this.dnsConfig = dnsConfig;
    return this;
  }

   /**
   * Get dnsConfig
   * @return dnsConfig
  **/
  @jakarta.annotation.Nullable
  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplateDnsConfig getDnsConfig() {
    return dnsConfig;
  }


  public void setDnsConfig(V1PipelineRunSpecTaskRunSpecsInnerPodTemplateDnsConfig dnsConfig) {
    this.dnsConfig = dnsConfig;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate dnsPolicy(String dnsPolicy) {
    
    this.dnsPolicy = dnsPolicy;
    return this;
  }

   /**
   * Set DNS policy for the pod. Defaults to \&quot;ClusterFirst\&quot;. Valid values are &#39;ClusterFirst&#39;, &#39;Default&#39; or &#39;None&#39;. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * @return dnsPolicy
  **/
  @jakarta.annotation.Nullable
  public String getDnsPolicy() {
    return dnsPolicy;
  }


  public void setDnsPolicy(String dnsPolicy) {
    this.dnsPolicy = dnsPolicy;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate enableServiceLinks(Boolean enableServiceLinks) {
    
    this.enableServiceLinks = enableServiceLinks;
    return this;
  }

   /**
   * EnableServiceLinks indicates whether information about services should be injected into pod&#39;s environment variables, matching the syntax of Docker links. Optional: Defaults to true.
   * @return enableServiceLinks
  **/
  @jakarta.annotation.Nullable
  public Boolean getEnableServiceLinks() {
    return enableServiceLinks;
  }


  public void setEnableServiceLinks(Boolean enableServiceLinks) {
    this.enableServiceLinks = enableServiceLinks;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate env(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateEnvInner> env) {
    
    this.env = env;
    return this;
  }

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate addEnvItem(V1PipelineRunSpecTaskRunSpecsInnerPodTemplateEnvInner envItem) {
    if (this.env == null) {
      this.env = new ArrayList<>();
    }
    this.env.add(envItem);
    return this;
  }

   /**
   * List of environment variables that can be provided to the containers belonging to the pod.
   * @return env
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateEnvInner> getEnv() {
    return env;
  }


  public void setEnv(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateEnvInner> env) {
    this.env = env;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate hostAliases(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateHostAliasesInner> hostAliases) {
    
    this.hostAliases = hostAliases;
    return this;
  }

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate addHostAliasesItem(V1PipelineRunSpecTaskRunSpecsInnerPodTemplateHostAliasesInner hostAliasesItem) {
    if (this.hostAliases == null) {
      this.hostAliases = new ArrayList<>();
    }
    this.hostAliases.add(hostAliasesItem);
    return this;
  }

   /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod&#39;s hosts file if specified. This is only valid for non-hostNetwork pods.
   * @return hostAliases
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateHostAliasesInner> getHostAliases() {
    return hostAliases;
  }


  public void setHostAliases(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateHostAliasesInner> hostAliases) {
    this.hostAliases = hostAliases;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate hostNetwork(Boolean hostNetwork) {
    
    this.hostNetwork = hostNetwork;
    return this;
  }

   /**
   * HostNetwork specifies whether the pod may use the node network namespace
   * @return hostNetwork
  **/
  @jakarta.annotation.Nullable
  public Boolean getHostNetwork() {
    return hostNetwork;
  }


  public void setHostNetwork(Boolean hostNetwork) {
    this.hostNetwork = hostNetwork;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate imagePullSecrets(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateImagePullSecretsInner> imagePullSecrets) {
    
    this.imagePullSecrets = imagePullSecrets;
    return this;
  }

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate addImagePullSecretsItem(V1PipelineRunSpecTaskRunSpecsInnerPodTemplateImagePullSecretsInner imagePullSecretsItem) {
    if (this.imagePullSecrets == null) {
      this.imagePullSecrets = new ArrayList<>();
    }
    this.imagePullSecrets.add(imagePullSecretsItem);
    return this;
  }

   /**
   * ImagePullSecrets gives the name of the secret used by the pod to pull the image if specified
   * @return imagePullSecrets
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateImagePullSecretsInner> getImagePullSecrets() {
    return imagePullSecrets;
  }


  public void setImagePullSecrets(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateImagePullSecretsInner> imagePullSecrets) {
    this.imagePullSecrets = imagePullSecrets;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate nodeSelector(Map<String, String> nodeSelector) {
    
    this.nodeSelector = nodeSelector;
    return this;
  }

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate putNodeSelectorItem(String key, String nodeSelectorItem) {
    if (this.nodeSelector == null) {
      this.nodeSelector = new HashMap<>();
    }
    this.nodeSelector.put(key, nodeSelectorItem);
    return this;
  }

   /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node&#39;s labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   * @return nodeSelector
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getNodeSelector() {
    return nodeSelector;
  }


  public void setNodeSelector(Map<String, String> nodeSelector) {
    this.nodeSelector = nodeSelector;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate priorityClassName(String priorityClassName) {
    
    this.priorityClassName = priorityClassName;
    return this;
  }

   /**
   * If specified, indicates the pod&#39;s priority. \&quot;system-node-critical\&quot; and \&quot;system-cluster-critical\&quot; are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   * @return priorityClassName
  **/
  @jakarta.annotation.Nullable
  public String getPriorityClassName() {
    return priorityClassName;
  }


  public void setPriorityClassName(String priorityClassName) {
    this.priorityClassName = priorityClassName;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate runtimeClassName(String runtimeClassName) {
    
    this.runtimeClassName = runtimeClassName;
    return this;
  }

   /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod. If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \&quot;legacy\&quot; RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md This is a beta feature as of Kubernetes v1.14.
   * @return runtimeClassName
  **/
  @jakarta.annotation.Nullable
  public String getRuntimeClassName() {
    return runtimeClassName;
  }


  public void setRuntimeClassName(String runtimeClassName) {
    this.runtimeClassName = runtimeClassName;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate schedulerName(String schedulerName) {
    
    this.schedulerName = schedulerName;
    return this;
  }

   /**
   * SchedulerName specifies the scheduler to be used to dispatch the Pod
   * @return schedulerName
  **/
  @jakarta.annotation.Nullable
  public String getSchedulerName() {
    return schedulerName;
  }


  public void setSchedulerName(String schedulerName) {
    this.schedulerName = schedulerName;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate securityContext(Object securityContext) {
    
    this.securityContext = securityContext;
    return this;
  }

   /**
   * SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field. See Pod.spec.securityContext (API version: v1)
   * @return securityContext
  **/
  @jakarta.annotation.Nullable
  public Object getSecurityContext() {
    return securityContext;
  }


  public void setSecurityContext(Object securityContext) {
    this.securityContext = securityContext;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate tolerations(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTolerationsInner> tolerations) {
    
    this.tolerations = tolerations;
    return this;
  }

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate addTolerationsItem(V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTolerationsInner tolerationsItem) {
    if (this.tolerations == null) {
      this.tolerations = new ArrayList<>();
    }
    this.tolerations.add(tolerationsItem);
    return this;
  }

   /**
   * If specified, the pod&#39;s tolerations.
   * @return tolerations
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTolerationsInner> getTolerations() {
    return tolerations;
  }


  public void setTolerations(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTolerationsInner> tolerations) {
    this.tolerations = tolerations;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate topologySpreadConstraints(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTopologySpreadConstraintsInner> topologySpreadConstraints) {
    
    this.topologySpreadConstraints = topologySpreadConstraints;
    return this;
  }

  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate addTopologySpreadConstraintsItem(V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTopologySpreadConstraintsInner topologySpreadConstraintsItem) {
    if (this.topologySpreadConstraints == null) {
      this.topologySpreadConstraints = new ArrayList<>();
    }
    this.topologySpreadConstraints.add(topologySpreadConstraintsItem);
    return this;
  }

   /**
   * TopologySpreadConstraints controls how Pods are spread across your cluster among failure-domains such as regions, zones, nodes, and other user-defined topology domains.
   * @return topologySpreadConstraints
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTopologySpreadConstraintsInner> getTopologySpreadConstraints() {
    return topologySpreadConstraints;
  }


  public void setTopologySpreadConstraints(List<V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTopologySpreadConstraintsInner> topologySpreadConstraints) {
    this.topologySpreadConstraints = topologySpreadConstraints;
  }


  public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate volumes(Object volumes) {
    
    this.volumes = volumes;
    return this;
  }

   /**
   * List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes See Pod.spec.volumes (API version: v1)
   * @return volumes
  **/
  @jakarta.annotation.Nullable
  public Object getVolumes() {
    return volumes;
  }


  public void setVolumes(Object volumes) {
    this.volumes = volumes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1PipelineRunSpecTaskRunSpecsInnerPodTemplate v1PipelineRunSpecTaskRunSpecsInnerPodTemplate = (V1PipelineRunSpecTaskRunSpecsInnerPodTemplate) o;
    return Objects.equals(this.affinity, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.affinity) &&
        Objects.equals(this.automountServiceAccountToken, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.automountServiceAccountToken) &&
        Objects.equals(this.dnsConfig, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.dnsConfig) &&
        Objects.equals(this.dnsPolicy, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.dnsPolicy) &&
        Objects.equals(this.enableServiceLinks, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.enableServiceLinks) &&
        Objects.equals(this.env, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.env) &&
        Objects.equals(this.hostAliases, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.hostAliases) &&
        Objects.equals(this.hostNetwork, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.hostNetwork) &&
        Objects.equals(this.imagePullSecrets, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.imagePullSecrets) &&
        Objects.equals(this.nodeSelector, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.nodeSelector) &&
        Objects.equals(this.priorityClassName, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.priorityClassName) &&
        Objects.equals(this.runtimeClassName, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.runtimeClassName) &&
        Objects.equals(this.schedulerName, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.schedulerName) &&
        Objects.equals(this.securityContext, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.securityContext) &&
        Objects.equals(this.tolerations, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.tolerations) &&
        Objects.equals(this.topologySpreadConstraints, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.topologySpreadConstraints) &&
        Objects.equals(this.volumes, v1PipelineRunSpecTaskRunSpecsInnerPodTemplate.volumes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(affinity, automountServiceAccountToken, dnsConfig, dnsPolicy, enableServiceLinks, env, hostAliases, hostNetwork, imagePullSecrets, nodeSelector, priorityClassName, runtimeClassName, schedulerName, securityContext, tolerations, topologySpreadConstraints, volumes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1PipelineRunSpecTaskRunSpecsInnerPodTemplate {\n");
    sb.append("    affinity: ").append(toIndentedString(affinity)).append("\n");
    sb.append("    automountServiceAccountToken: ").append(toIndentedString(automountServiceAccountToken)).append("\n");
    sb.append("    dnsConfig: ").append(toIndentedString(dnsConfig)).append("\n");
    sb.append("    dnsPolicy: ").append(toIndentedString(dnsPolicy)).append("\n");
    sb.append("    enableServiceLinks: ").append(toIndentedString(enableServiceLinks)).append("\n");
    sb.append("    env: ").append(toIndentedString(env)).append("\n");
    sb.append("    hostAliases: ").append(toIndentedString(hostAliases)).append("\n");
    sb.append("    hostNetwork: ").append(toIndentedString(hostNetwork)).append("\n");
    sb.append("    imagePullSecrets: ").append(toIndentedString(imagePullSecrets)).append("\n");
    sb.append("    nodeSelector: ").append(toIndentedString(nodeSelector)).append("\n");
    sb.append("    priorityClassName: ").append(toIndentedString(priorityClassName)).append("\n");
    sb.append("    runtimeClassName: ").append(toIndentedString(runtimeClassName)).append("\n");
    sb.append("    schedulerName: ").append(toIndentedString(schedulerName)).append("\n");
    sb.append("    securityContext: ").append(toIndentedString(securityContext)).append("\n");
    sb.append("    tolerations: ").append(toIndentedString(tolerations)).append("\n");
    sb.append("    topologySpreadConstraints: ").append(toIndentedString(topologySpreadConstraints)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("affinity");
    openapiFields.add("automountServiceAccountToken");
    openapiFields.add("dnsConfig");
    openapiFields.add("dnsPolicy");
    openapiFields.add("enableServiceLinks");
    openapiFields.add("env");
    openapiFields.add("hostAliases");
    openapiFields.add("hostNetwork");
    openapiFields.add("imagePullSecrets");
    openapiFields.add("nodeSelector");
    openapiFields.add("priorityClassName");
    openapiFields.add("runtimeClassName");
    openapiFields.add("schedulerName");
    openapiFields.add("securityContext");
    openapiFields.add("tolerations");
    openapiFields.add("topologySpreadConstraints");
    openapiFields.add("volumes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1PipelineRunSpecTaskRunSpecsInnerPodTemplate
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1PipelineRunSpecTaskRunSpecsInnerPodTemplate.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1PipelineRunSpecTaskRunSpecsInnerPodTemplate is not found in the empty JSON string", V1PipelineRunSpecTaskRunSpecsInnerPodTemplate.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1PipelineRunSpecTaskRunSpecsInnerPodTemplate.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1PipelineRunSpecTaskRunSpecsInnerPodTemplate` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field `dnsConfig`
      if (jsonObj.get("dnsConfig") != null && !jsonObj.get("dnsConfig").isJsonNull()) {
        V1PipelineRunSpecTaskRunSpecsInnerPodTemplateDnsConfig.validateJsonObject(jsonObj.getAsJsonObject("dnsConfig"));
      }
      if ((jsonObj.get("dnsPolicy") != null && !jsonObj.get("dnsPolicy").isJsonNull()) && !jsonObj.get("dnsPolicy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dnsPolicy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dnsPolicy").toString()));
      }
      if (jsonObj.get("env") != null && !jsonObj.get("env").isJsonNull()) {
        JsonArray jsonArrayenv = jsonObj.getAsJsonArray("env");
        if (jsonArrayenv != null) {
          // ensure the json data is an array
          if (!jsonObj.get("env").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `env` to be an array in the JSON string but got `%s`", jsonObj.get("env").toString()));
          }

          // validate the optional field `env` (array)
          for (int i = 0; i < jsonArrayenv.size(); i++) {
            V1PipelineRunSpecTaskRunSpecsInnerPodTemplateEnvInner.validateJsonObject(jsonArrayenv.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("hostAliases") != null && !jsonObj.get("hostAliases").isJsonNull()) {
        JsonArray jsonArrayhostAliases = jsonObj.getAsJsonArray("hostAliases");
        if (jsonArrayhostAliases != null) {
          // ensure the json data is an array
          if (!jsonObj.get("hostAliases").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `hostAliases` to be an array in the JSON string but got `%s`", jsonObj.get("hostAliases").toString()));
          }

          // validate the optional field `hostAliases` (array)
          for (int i = 0; i < jsonArrayhostAliases.size(); i++) {
            V1PipelineRunSpecTaskRunSpecsInnerPodTemplateHostAliasesInner.validateJsonObject(jsonArrayhostAliases.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("imagePullSecrets") != null && !jsonObj.get("imagePullSecrets").isJsonNull()) {
        JsonArray jsonArrayimagePullSecrets = jsonObj.getAsJsonArray("imagePullSecrets");
        if (jsonArrayimagePullSecrets != null) {
          // ensure the json data is an array
          if (!jsonObj.get("imagePullSecrets").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `imagePullSecrets` to be an array in the JSON string but got `%s`", jsonObj.get("imagePullSecrets").toString()));
          }

          // validate the optional field `imagePullSecrets` (array)
          for (int i = 0; i < jsonArrayimagePullSecrets.size(); i++) {
            V1PipelineRunSpecTaskRunSpecsInnerPodTemplateImagePullSecretsInner.validateJsonObject(jsonArrayimagePullSecrets.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("priorityClassName") != null && !jsonObj.get("priorityClassName").isJsonNull()) && !jsonObj.get("priorityClassName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `priorityClassName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("priorityClassName").toString()));
      }
      if ((jsonObj.get("runtimeClassName") != null && !jsonObj.get("runtimeClassName").isJsonNull()) && !jsonObj.get("runtimeClassName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `runtimeClassName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("runtimeClassName").toString()));
      }
      if ((jsonObj.get("schedulerName") != null && !jsonObj.get("schedulerName").isJsonNull()) && !jsonObj.get("schedulerName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `schedulerName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("schedulerName").toString()));
      }
      if (jsonObj.get("tolerations") != null && !jsonObj.get("tolerations").isJsonNull()) {
        JsonArray jsonArraytolerations = jsonObj.getAsJsonArray("tolerations");
        if (jsonArraytolerations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("tolerations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `tolerations` to be an array in the JSON string but got `%s`", jsonObj.get("tolerations").toString()));
          }

          // validate the optional field `tolerations` (array)
          for (int i = 0; i < jsonArraytolerations.size(); i++) {
            V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTolerationsInner.validateJsonObject(jsonArraytolerations.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("topologySpreadConstraints") != null && !jsonObj.get("topologySpreadConstraints").isJsonNull()) {
        JsonArray jsonArraytopologySpreadConstraints = jsonObj.getAsJsonArray("topologySpreadConstraints");
        if (jsonArraytopologySpreadConstraints != null) {
          // ensure the json data is an array
          if (!jsonObj.get("topologySpreadConstraints").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `topologySpreadConstraints` to be an array in the JSON string but got `%s`", jsonObj.get("topologySpreadConstraints").toString()));
          }

          // validate the optional field `topologySpreadConstraints` (array)
          for (int i = 0; i < jsonArraytopologySpreadConstraints.size(); i++) {
            V1PipelineRunSpecTaskRunSpecsInnerPodTemplateTopologySpreadConstraintsInner.validateJsonObject(jsonArraytopologySpreadConstraints.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1PipelineRunSpecTaskRunSpecsInnerPodTemplate.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1PipelineRunSpecTaskRunSpecsInnerPodTemplate' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1PipelineRunSpecTaskRunSpecsInnerPodTemplate> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1PipelineRunSpecTaskRunSpecsInnerPodTemplate.class));

       return (TypeAdapter<T>) new TypeAdapter<V1PipelineRunSpecTaskRunSpecsInnerPodTemplate>() {
           @Override
           public void write(JsonWriter out, V1PipelineRunSpecTaskRunSpecsInnerPodTemplate value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1PipelineRunSpecTaskRunSpecsInnerPodTemplate read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1PipelineRunSpecTaskRunSpecsInnerPodTemplate given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1PipelineRunSpecTaskRunSpecsInnerPodTemplate
  * @throws IOException if the JSON string is invalid with respect to V1PipelineRunSpecTaskRunSpecsInnerPodTemplate
  */
  public static V1PipelineRunSpecTaskRunSpecsInnerPodTemplate fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1PipelineRunSpecTaskRunSpecsInnerPodTemplate.class);
  }

 /**
  * Convert an instance of V1PipelineRunSpecTaskRunSpecsInnerPodTemplate to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


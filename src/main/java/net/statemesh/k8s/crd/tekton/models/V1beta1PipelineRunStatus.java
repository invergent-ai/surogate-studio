/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.tekton.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusChildReferencesInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusConditionsInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusResultsInner;
import net.statemesh.k8s.crd.tekton.models.V1PipelineRunStatusSkippedTasksInner;
import net.statemesh.k8s.crd.tekton.models.V1beta1PipelineRunStatusProvenance;
import net.statemesh.k8s.crd.tekton.models.V1beta1PipelineRunStatusRunsValue;
import net.statemesh.k8s.crd.tekton.models.V1beta1PipelineRunStatusTaskRunsValue;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * PipelineRunStatus defines the observed state of PipelineRun
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-10-01T09:42:24.724862Z[Etc/UTC]")
public class V1beta1PipelineRunStatus {
  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private Map<String, String> annotations = new HashMap<>();

  public static final String SERIALIZED_NAME_CHILD_REFERENCES = "childReferences";
  @SerializedName(SERIALIZED_NAME_CHILD_REFERENCES)
  private List<V1PipelineRunStatusChildReferencesInner> childReferences;

  public static final String SERIALIZED_NAME_COMPLETION_TIME = "completionTime";
  @SerializedName(SERIALIZED_NAME_COMPLETION_TIME)
  private OffsetDateTime completionTime;

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private List<V1PipelineRunStatusConditionsInner> conditions;

  public static final String SERIALIZED_NAME_FINALLY_START_TIME = "finallyStartTime";
  @SerializedName(SERIALIZED_NAME_FINALLY_START_TIME)
  private OffsetDateTime finallyStartTime;

  public static final String SERIALIZED_NAME_OBSERVED_GENERATION = "observedGeneration";
  @SerializedName(SERIALIZED_NAME_OBSERVED_GENERATION)
  private Long observedGeneration;

  public static final String SERIALIZED_NAME_PIPELINE_RESULTS = "pipelineResults";
  @SerializedName(SERIALIZED_NAME_PIPELINE_RESULTS)
  private List<V1PipelineRunStatusResultsInner> pipelineResults;

  public static final String SERIALIZED_NAME_PIPELINE_SPEC = "pipelineSpec";
  @SerializedName(SERIALIZED_NAME_PIPELINE_SPEC)
  private Object pipelineSpec;

  public static final String SERIALIZED_NAME_PROVENANCE = "provenance";
  @SerializedName(SERIALIZED_NAME_PROVENANCE)
  private V1beta1PipelineRunStatusProvenance provenance;

  public static final String SERIALIZED_NAME_RUNS = "runs";
  @SerializedName(SERIALIZED_NAME_RUNS)
  private Map<String, V1beta1PipelineRunStatusRunsValue> runs = new HashMap<>();

  public static final String SERIALIZED_NAME_SKIPPED_TASKS = "skippedTasks";
  @SerializedName(SERIALIZED_NAME_SKIPPED_TASKS)
  private List<V1PipelineRunStatusSkippedTasksInner> skippedTasks;

  public static final String SERIALIZED_NAME_SPAN_CONTEXT = "spanContext";
  @SerializedName(SERIALIZED_NAME_SPAN_CONTEXT)
  private Map<String, String> spanContext = new HashMap<>();

  public static final String SERIALIZED_NAME_START_TIME = "startTime";
  @SerializedName(SERIALIZED_NAME_START_TIME)
  private OffsetDateTime startTime;

  public static final String SERIALIZED_NAME_TASK_RUNS = "taskRuns";
  @SerializedName(SERIALIZED_NAME_TASK_RUNS)
  private Map<String, V1beta1PipelineRunStatusTaskRunsValue> taskRuns = new HashMap<>();

  public V1beta1PipelineRunStatus() {
  }

  public V1beta1PipelineRunStatus annotations(Map<String, String> annotations) {
    
    this.annotations = annotations;
    return this;
  }

  public V1beta1PipelineRunStatus putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

   /**
   * Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
   * @return annotations
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getAnnotations() {
    return annotations;
  }


  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }


  public V1beta1PipelineRunStatus childReferences(List<V1PipelineRunStatusChildReferencesInner> childReferences) {
    
    this.childReferences = childReferences;
    return this;
  }

  public V1beta1PipelineRunStatus addChildReferencesItem(V1PipelineRunStatusChildReferencesInner childReferencesItem) {
    if (this.childReferences == null) {
      this.childReferences = new ArrayList<>();
    }
    this.childReferences.add(childReferencesItem);
    return this;
  }

   /**
   * list of TaskRun and Run names, PipelineTask names, and API versions/kinds for children of this PipelineRun.
   * @return childReferences
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusChildReferencesInner> getChildReferences() {
    return childReferences;
  }


  public void setChildReferences(List<V1PipelineRunStatusChildReferencesInner> childReferences) {
    this.childReferences = childReferences;
  }


  public V1beta1PipelineRunStatus completionTime(OffsetDateTime completionTime) {
    
    this.completionTime = completionTime;
    return this;
  }

   /**
   * CompletionTime is the time the PipelineRun completed.
   * @return completionTime
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getCompletionTime() {
    return completionTime;
  }


  public void setCompletionTime(OffsetDateTime completionTime) {
    this.completionTime = completionTime;
  }


  public V1beta1PipelineRunStatus conditions(List<V1PipelineRunStatusConditionsInner> conditions) {
    
    this.conditions = conditions;
    return this;
  }

  public V1beta1PipelineRunStatus addConditionsItem(V1PipelineRunStatusConditionsInner conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * Conditions the latest available observations of a resource&#39;s current state.
   * @return conditions
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusConditionsInner> getConditions() {
    return conditions;
  }


  public void setConditions(List<V1PipelineRunStatusConditionsInner> conditions) {
    this.conditions = conditions;
  }


  public V1beta1PipelineRunStatus finallyStartTime(OffsetDateTime finallyStartTime) {
    
    this.finallyStartTime = finallyStartTime;
    return this;
  }

   /**
   * FinallyStartTime is when all non-finally tasks have been completed and only finally tasks are being executed.
   * @return finallyStartTime
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getFinallyStartTime() {
    return finallyStartTime;
  }


  public void setFinallyStartTime(OffsetDateTime finallyStartTime) {
    this.finallyStartTime = finallyStartTime;
  }


  public V1beta1PipelineRunStatus observedGeneration(Long observedGeneration) {
    
    this.observedGeneration = observedGeneration;
    return this;
  }

   /**
   * ObservedGeneration is the &#39;Generation&#39; of the Service that was last processed by the controller.
   * @return observedGeneration
  **/
  @jakarta.annotation.Nullable
  public Long getObservedGeneration() {
    return observedGeneration;
  }


  public void setObservedGeneration(Long observedGeneration) {
    this.observedGeneration = observedGeneration;
  }


  public V1beta1PipelineRunStatus pipelineResults(List<V1PipelineRunStatusResultsInner> pipelineResults) {
    
    this.pipelineResults = pipelineResults;
    return this;
  }

  public V1beta1PipelineRunStatus addPipelineResultsItem(V1PipelineRunStatusResultsInner pipelineResultsItem) {
    if (this.pipelineResults == null) {
      this.pipelineResults = new ArrayList<>();
    }
    this.pipelineResults.add(pipelineResultsItem);
    return this;
  }

   /**
   * PipelineResults are the list of results written out by the pipeline task&#39;s containers
   * @return pipelineResults
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusResultsInner> getPipelineResults() {
    return pipelineResults;
  }


  public void setPipelineResults(List<V1PipelineRunStatusResultsInner> pipelineResults) {
    this.pipelineResults = pipelineResults;
  }


  public V1beta1PipelineRunStatus pipelineSpec(Object pipelineSpec) {
    
    this.pipelineSpec = pipelineSpec;
    return this;
  }

   /**
   * PipelineSpec contains the exact spec used to instantiate the run. See Pipeline.spec (API version: tekton.dev/v1beta1)
   * @return pipelineSpec
  **/
  @jakarta.annotation.Nullable
  public Object getPipelineSpec() {
    return pipelineSpec;
  }


  public void setPipelineSpec(Object pipelineSpec) {
    this.pipelineSpec = pipelineSpec;
  }


  public V1beta1PipelineRunStatus provenance(V1beta1PipelineRunStatusProvenance provenance) {
    
    this.provenance = provenance;
    return this;
  }

   /**
   * Get provenance
   * @return provenance
  **/
  @jakarta.annotation.Nullable
  public V1beta1PipelineRunStatusProvenance getProvenance() {
    return provenance;
  }


  public void setProvenance(V1beta1PipelineRunStatusProvenance provenance) {
    this.provenance = provenance;
  }


  public V1beta1PipelineRunStatus runs(Map<String, V1beta1PipelineRunStatusRunsValue> runs) {
    
    this.runs = runs;
    return this;
  }

  public V1beta1PipelineRunStatus putRunsItem(String key, V1beta1PipelineRunStatusRunsValue runsItem) {
    if (this.runs == null) {
      this.runs = new HashMap<>();
    }
    this.runs.put(key, runsItem);
    return this;
  }

   /**
   * Runs is a map of PipelineRunRunStatus with the run name as the key  Deprecated: use ChildReferences instead. As of v0.45.0, this field is no longer populated and is only included for backwards compatibility with older server versions.
   * @return runs
  **/
  @jakarta.annotation.Nullable
  public Map<String, V1beta1PipelineRunStatusRunsValue> getRuns() {
    return runs;
  }


  public void setRuns(Map<String, V1beta1PipelineRunStatusRunsValue> runs) {
    this.runs = runs;
  }


  public V1beta1PipelineRunStatus skippedTasks(List<V1PipelineRunStatusSkippedTasksInner> skippedTasks) {
    
    this.skippedTasks = skippedTasks;
    return this;
  }

  public V1beta1PipelineRunStatus addSkippedTasksItem(V1PipelineRunStatusSkippedTasksInner skippedTasksItem) {
    if (this.skippedTasks == null) {
      this.skippedTasks = new ArrayList<>();
    }
    this.skippedTasks.add(skippedTasksItem);
    return this;
  }

   /**
   * list of tasks that were skipped due to when expressions evaluating to false
   * @return skippedTasks
  **/
  @jakarta.annotation.Nullable
  public List<V1PipelineRunStatusSkippedTasksInner> getSkippedTasks() {
    return skippedTasks;
  }


  public void setSkippedTasks(List<V1PipelineRunStatusSkippedTasksInner> skippedTasks) {
    this.skippedTasks = skippedTasks;
  }


  public V1beta1PipelineRunStatus spanContext(Map<String, String> spanContext) {
    
    this.spanContext = spanContext;
    return this;
  }

  public V1beta1PipelineRunStatus putSpanContextItem(String key, String spanContextItem) {
    if (this.spanContext == null) {
      this.spanContext = new HashMap<>();
    }
    this.spanContext.put(key, spanContextItem);
    return this;
  }

   /**
   * SpanContext contains tracing span context fields
   * @return spanContext
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getSpanContext() {
    return spanContext;
  }


  public void setSpanContext(Map<String, String> spanContext) {
    this.spanContext = spanContext;
  }


  public V1beta1PipelineRunStatus startTime(OffsetDateTime startTime) {
    
    this.startTime = startTime;
    return this;
  }

   /**
   * StartTime is the time the PipelineRun is actually started.
   * @return startTime
  **/
  @jakarta.annotation.Nullable
  public OffsetDateTime getStartTime() {
    return startTime;
  }


  public void setStartTime(OffsetDateTime startTime) {
    this.startTime = startTime;
  }


  public V1beta1PipelineRunStatus taskRuns(Map<String, V1beta1PipelineRunStatusTaskRunsValue> taskRuns) {
    
    this.taskRuns = taskRuns;
    return this;
  }

  public V1beta1PipelineRunStatus putTaskRunsItem(String key, V1beta1PipelineRunStatusTaskRunsValue taskRunsItem) {
    if (this.taskRuns == null) {
      this.taskRuns = new HashMap<>();
    }
    this.taskRuns.put(key, taskRunsItem);
    return this;
  }

   /**
   * TaskRuns is a map of PipelineRunTaskRunStatus with the taskRun name as the key.  Deprecated: use ChildReferences instead. As of v0.45.0, this field is no longer populated and is only included for backwards compatibility with older server versions.
   * @return taskRuns
  **/
  @jakarta.annotation.Nullable
  public Map<String, V1beta1PipelineRunStatusTaskRunsValue> getTaskRuns() {
    return taskRuns;
  }


  public void setTaskRuns(Map<String, V1beta1PipelineRunStatusTaskRunsValue> taskRuns) {
    this.taskRuns = taskRuns;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1beta1PipelineRunStatus v1beta1PipelineRunStatus = (V1beta1PipelineRunStatus) o;
    return Objects.equals(this.annotations, v1beta1PipelineRunStatus.annotations) &&
        Objects.equals(this.childReferences, v1beta1PipelineRunStatus.childReferences) &&
        Objects.equals(this.completionTime, v1beta1PipelineRunStatus.completionTime) &&
        Objects.equals(this.conditions, v1beta1PipelineRunStatus.conditions) &&
        Objects.equals(this.finallyStartTime, v1beta1PipelineRunStatus.finallyStartTime) &&
        Objects.equals(this.observedGeneration, v1beta1PipelineRunStatus.observedGeneration) &&
        Objects.equals(this.pipelineResults, v1beta1PipelineRunStatus.pipelineResults) &&
        Objects.equals(this.pipelineSpec, v1beta1PipelineRunStatus.pipelineSpec) &&
        Objects.equals(this.provenance, v1beta1PipelineRunStatus.provenance) &&
        Objects.equals(this.runs, v1beta1PipelineRunStatus.runs) &&
        Objects.equals(this.skippedTasks, v1beta1PipelineRunStatus.skippedTasks) &&
        Objects.equals(this.spanContext, v1beta1PipelineRunStatus.spanContext) &&
        Objects.equals(this.startTime, v1beta1PipelineRunStatus.startTime) &&
        Objects.equals(this.taskRuns, v1beta1PipelineRunStatus.taskRuns);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotations, childReferences, completionTime, conditions, finallyStartTime, observedGeneration, pipelineResults, pipelineSpec, provenance, runs, skippedTasks, spanContext, startTime, taskRuns);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1beta1PipelineRunStatus {\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    childReferences: ").append(toIndentedString(childReferences)).append("\n");
    sb.append("    completionTime: ").append(toIndentedString(completionTime)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    finallyStartTime: ").append(toIndentedString(finallyStartTime)).append("\n");
    sb.append("    observedGeneration: ").append(toIndentedString(observedGeneration)).append("\n");
    sb.append("    pipelineResults: ").append(toIndentedString(pipelineResults)).append("\n");
    sb.append("    pipelineSpec: ").append(toIndentedString(pipelineSpec)).append("\n");
    sb.append("    provenance: ").append(toIndentedString(provenance)).append("\n");
    sb.append("    runs: ").append(toIndentedString(runs)).append("\n");
    sb.append("    skippedTasks: ").append(toIndentedString(skippedTasks)).append("\n");
    sb.append("    spanContext: ").append(toIndentedString(spanContext)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    taskRuns: ").append(toIndentedString(taskRuns)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotations");
    openapiFields.add("childReferences");
    openapiFields.add("completionTime");
    openapiFields.add("conditions");
    openapiFields.add("finallyStartTime");
    openapiFields.add("observedGeneration");
    openapiFields.add("pipelineResults");
    openapiFields.add("pipelineSpec");
    openapiFields.add("provenance");
    openapiFields.add("runs");
    openapiFields.add("skippedTasks");
    openapiFields.add("spanContext");
    openapiFields.add("startTime");
    openapiFields.add("taskRuns");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1beta1PipelineRunStatus
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1beta1PipelineRunStatus.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1beta1PipelineRunStatus is not found in the empty JSON string", V1beta1PipelineRunStatus.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1beta1PipelineRunStatus.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1beta1PipelineRunStatus` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if (jsonObj.get("childReferences") != null && !jsonObj.get("childReferences").isJsonNull()) {
        JsonArray jsonArraychildReferences = jsonObj.getAsJsonArray("childReferences");
        if (jsonArraychildReferences != null) {
          // ensure the json data is an array
          if (!jsonObj.get("childReferences").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `childReferences` to be an array in the JSON string but got `%s`", jsonObj.get("childReferences").toString()));
          }

          // validate the optional field `childReferences` (array)
          for (int i = 0; i < jsonArraychildReferences.size(); i++) {
            V1PipelineRunStatusChildReferencesInner.validateJsonObject(jsonArraychildReferences.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("conditions") != null && !jsonObj.get("conditions").isJsonNull()) {
        JsonArray jsonArrayconditions = jsonObj.getAsJsonArray("conditions");
        if (jsonArrayconditions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("conditions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `conditions` to be an array in the JSON string but got `%s`", jsonObj.get("conditions").toString()));
          }

          // validate the optional field `conditions` (array)
          for (int i = 0; i < jsonArrayconditions.size(); i++) {
            V1PipelineRunStatusConditionsInner.validateJsonObject(jsonArrayconditions.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("pipelineResults") != null && !jsonObj.get("pipelineResults").isJsonNull()) {
        JsonArray jsonArraypipelineResults = jsonObj.getAsJsonArray("pipelineResults");
        if (jsonArraypipelineResults != null) {
          // ensure the json data is an array
          if (!jsonObj.get("pipelineResults").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `pipelineResults` to be an array in the JSON string but got `%s`", jsonObj.get("pipelineResults").toString()));
          }

          // validate the optional field `pipelineResults` (array)
          for (int i = 0; i < jsonArraypipelineResults.size(); i++) {
            V1PipelineRunStatusResultsInner.validateJsonObject(jsonArraypipelineResults.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `provenance`
      if (jsonObj.get("provenance") != null && !jsonObj.get("provenance").isJsonNull()) {
        V1beta1PipelineRunStatusProvenance.validateJsonObject(jsonObj.getAsJsonObject("provenance"));
      }
      if (jsonObj.get("skippedTasks") != null && !jsonObj.get("skippedTasks").isJsonNull()) {
        JsonArray jsonArrayskippedTasks = jsonObj.getAsJsonArray("skippedTasks");
        if (jsonArrayskippedTasks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("skippedTasks").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `skippedTasks` to be an array in the JSON string but got `%s`", jsonObj.get("skippedTasks").toString()));
          }

          // validate the optional field `skippedTasks` (array)
          for (int i = 0; i < jsonArrayskippedTasks.size(); i++) {
            V1PipelineRunStatusSkippedTasksInner.validateJsonObject(jsonArrayskippedTasks.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1beta1PipelineRunStatus.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1beta1PipelineRunStatus' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1beta1PipelineRunStatus> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1beta1PipelineRunStatus.class));

       return (TypeAdapter<T>) new TypeAdapter<V1beta1PipelineRunStatus>() {
           @Override
           public void write(JsonWriter out, V1beta1PipelineRunStatus value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1beta1PipelineRunStatus read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1beta1PipelineRunStatus given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1beta1PipelineRunStatus
  * @throws IOException if the JSON string is invalid with respect to V1beta1PipelineRunStatus
  */
  public static V1beta1PipelineRunStatus fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1beta1PipelineRunStatus.class);
  }

 /**
  * Convert an instance of V1beta1PipelineRunStatus to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.tekton.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * TaskResource defines an input or output Resource declared as a requirement by a Task. The Name field will be used to refer to these Resources within the Task definition, and when provided as an Input, the Name will be the path to the volume mounted containing this Resource as an input (e.g. an input Resource named &#x60;workspace&#x60; will be mounted at &#x60;/workspace&#x60;).  Deprecated: Unused, preserved only for backwards compatibility
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-10-01T09:42:24.724862Z[Etc/UTC]")
public class V1beta1TaskSpecResourcesInputsInner {
  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OPTIONAL = "optional";
  @SerializedName(SERIALIZED_NAME_OPTIONAL)
  private Boolean optional;

  public static final String SERIALIZED_NAME_TARGET_PATH = "targetPath";
  @SerializedName(SERIALIZED_NAME_TARGET_PATH)
  private String targetPath;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public V1beta1TaskSpecResourcesInputsInner() {
  }

  public V1beta1TaskSpecResourcesInputsInner description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * Description is a user-facing description of the declared resource that may be used to populate a UI.
   * @return description
  **/
  @jakarta.annotation.Nullable
  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


  public V1beta1TaskSpecResourcesInputsInner name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Name declares the name by which a resource is referenced in the definition. Resources may be referenced by name in the definition of a Task&#39;s steps.
   * @return name
  **/
  @jakarta.annotation.Nonnull
  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public V1beta1TaskSpecResourcesInputsInner optional(Boolean optional) {
    
    this.optional = optional;
    return this;
  }

   /**
   * Optional declares the resource as optional. By default optional is set to false which makes a resource required. optional: true - the resource is considered optional optional: false - the resource is considered required (equivalent of not specifying it)
   * @return optional
  **/
  @jakarta.annotation.Nullable
  public Boolean getOptional() {
    return optional;
  }


  public void setOptional(Boolean optional) {
    this.optional = optional;
  }


  public V1beta1TaskSpecResourcesInputsInner targetPath(String targetPath) {
    
    this.targetPath = targetPath;
    return this;
  }

   /**
   * TargetPath is the path in workspace directory where the resource will be copied.
   * @return targetPath
  **/
  @jakarta.annotation.Nullable
  public String getTargetPath() {
    return targetPath;
  }


  public void setTargetPath(String targetPath) {
    this.targetPath = targetPath;
  }


  public V1beta1TaskSpecResourcesInputsInner type(String type) {
    
    this.type = type;
    return this;
  }

   /**
   * Type is the type of this resource;
   * @return type
  **/
  @jakarta.annotation.Nonnull
  public String getType() {
    return type;
  }


  public void setType(String type) {
    this.type = type;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1beta1TaskSpecResourcesInputsInner v1beta1TaskSpecResourcesInputsInner = (V1beta1TaskSpecResourcesInputsInner) o;
    return Objects.equals(this.description, v1beta1TaskSpecResourcesInputsInner.description) &&
        Objects.equals(this.name, v1beta1TaskSpecResourcesInputsInner.name) &&
        Objects.equals(this.optional, v1beta1TaskSpecResourcesInputsInner.optional) &&
        Objects.equals(this.targetPath, v1beta1TaskSpecResourcesInputsInner.targetPath) &&
        Objects.equals(this.type, v1beta1TaskSpecResourcesInputsInner.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(description, name, optional, targetPath, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1beta1TaskSpecResourcesInputsInner {\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    optional: ").append(toIndentedString(optional)).append("\n");
    sb.append("    targetPath: ").append(toIndentedString(targetPath)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("description");
    openapiFields.add("name");
    openapiFields.add("optional");
    openapiFields.add("targetPath");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("type");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1beta1TaskSpecResourcesInputsInner
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1beta1TaskSpecResourcesInputsInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1beta1TaskSpecResourcesInputsInner is not found in the empty JSON string", V1beta1TaskSpecResourcesInputsInner.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1beta1TaskSpecResourcesInputsInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1beta1TaskSpecResourcesInputsInner` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : V1beta1TaskSpecResourcesInputsInner.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("targetPath") != null && !jsonObj.get("targetPath").isJsonNull()) && !jsonObj.get("targetPath").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `targetPath` to be a primitive type in the JSON string but got `%s`", jsonObj.get("targetPath").toString()));
      }
      if (!jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1beta1TaskSpecResourcesInputsInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1beta1TaskSpecResourcesInputsInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1beta1TaskSpecResourcesInputsInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1beta1TaskSpecResourcesInputsInner.class));

       return (TypeAdapter<T>) new TypeAdapter<V1beta1TaskSpecResourcesInputsInner>() {
           @Override
           public void write(JsonWriter out, V1beta1TaskSpecResourcesInputsInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1beta1TaskSpecResourcesInputsInner read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1beta1TaskSpecResourcesInputsInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1beta1TaskSpecResourcesInputsInner
  * @throws IOException if the JSON string is invalid with respect to V1beta1TaskSpecResourcesInputsInner
  */
  public static V1beta1TaskSpecResourcesInputsInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1beta1TaskSpecResourcesInputsInner.class);
  }

 /**
  * Convert an instance of V1beta1TaskSpecResourcesInputsInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}


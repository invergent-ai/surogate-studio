/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.25.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package net.statemesh.k8s.crd.raycluster.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import net.statemesh.k8s.crd.raycluster.models.V1RayClusterSpecHeadGroupSpecHeadServiceStatusConditionsInner;
import net.statemesh.k8s.crd.raycluster.models.V1RayClusterStatusHead;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * V1RayClusterStatus
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-11T07:02:16.267867Z[Etc/UTC]")
public class V1RayClusterStatus {
  public static final String SERIALIZED_NAME_AVAILABLE_WORKER_REPLICAS = "availableWorkerReplicas";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_WORKER_REPLICAS)
  private Integer availableWorkerReplicas;

  public static final String SERIALIZED_NAME_CONDITIONS = "conditions";
  @SerializedName(SERIALIZED_NAME_CONDITIONS)
  private List<V1RayClusterSpecHeadGroupSpecHeadServiceStatusConditionsInner> conditions;

  public static final String SERIALIZED_NAME_DESIRED_C_P_U = "desiredCPU";
  @SerializedName(SERIALIZED_NAME_DESIRED_C_P_U)
  private Object desiredCPU;

  public static final String SERIALIZED_NAME_DESIRED_G_P_U = "desiredGPU";
  @SerializedName(SERIALIZED_NAME_DESIRED_G_P_U)
  private Object desiredGPU;

  public static final String SERIALIZED_NAME_DESIRED_MEMORY = "desiredMemory";
  @SerializedName(SERIALIZED_NAME_DESIRED_MEMORY)
  private Object desiredMemory;

  public static final String SERIALIZED_NAME_DESIRED_T_P_U = "desiredTPU";
  @SerializedName(SERIALIZED_NAME_DESIRED_T_P_U)
  private Object desiredTPU;

  public static final String SERIALIZED_NAME_DESIRED_WORKER_REPLICAS = "desiredWorkerReplicas";
  @SerializedName(SERIALIZED_NAME_DESIRED_WORKER_REPLICAS)
  private Integer desiredWorkerReplicas;

  public static final String SERIALIZED_NAME_ENDPOINTS = "endpoints";
  @SerializedName(SERIALIZED_NAME_ENDPOINTS)
  private Map<String, String> endpoints = new HashMap<>();

  public static final String SERIALIZED_NAME_HEAD = "head";
  @SerializedName(SERIALIZED_NAME_HEAD)
  private V1RayClusterStatusHead head;

  public static final String SERIALIZED_NAME_LAST_UPDATE_TIME = "lastUpdateTime";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATE_TIME)
  private Object lastUpdateTime;

  public static final String SERIALIZED_NAME_MAX_WORKER_REPLICAS = "maxWorkerReplicas";
  @SerializedName(SERIALIZED_NAME_MAX_WORKER_REPLICAS)
  private Integer maxWorkerReplicas;

  public static final String SERIALIZED_NAME_MIN_WORKER_REPLICAS = "minWorkerReplicas";
  @SerializedName(SERIALIZED_NAME_MIN_WORKER_REPLICAS)
  private Integer minWorkerReplicas;

  public static final String SERIALIZED_NAME_OBSERVED_GENERATION = "observedGeneration";
  @SerializedName(SERIALIZED_NAME_OBSERVED_GENERATION)
  private Long observedGeneration;

  public static final String SERIALIZED_NAME_READY_WORKER_REPLICAS = "readyWorkerReplicas";
  @SerializedName(SERIALIZED_NAME_READY_WORKER_REPLICAS)
  private Integer readyWorkerReplicas;

  public static final String SERIALIZED_NAME_REASON = "reason";
  @SerializedName(SERIALIZED_NAME_REASON)
  private String reason;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  private String state;

  public static final String SERIALIZED_NAME_STATE_TRANSITION_TIMES = "stateTransitionTimes";
  @SerializedName(SERIALIZED_NAME_STATE_TRANSITION_TIMES)
  private Map<String, OffsetDateTime> stateTransitionTimes = new HashMap<>();

  public V1RayClusterStatus() {
  }

  public V1RayClusterStatus availableWorkerReplicas(Integer availableWorkerReplicas) {
    
    this.availableWorkerReplicas = availableWorkerReplicas;
    return this;
  }

   /**
   * Get availableWorkerReplicas
   * @return availableWorkerReplicas
  **/
  @jakarta.annotation.Nullable
  public Integer getAvailableWorkerReplicas() {
    return availableWorkerReplicas;
  }


  public void setAvailableWorkerReplicas(Integer availableWorkerReplicas) {
    this.availableWorkerReplicas = availableWorkerReplicas;
  }


  public V1RayClusterStatus conditions(List<V1RayClusterSpecHeadGroupSpecHeadServiceStatusConditionsInner> conditions) {
    
    this.conditions = conditions;
    return this;
  }

  public V1RayClusterStatus addConditionsItem(V1RayClusterSpecHeadGroupSpecHeadServiceStatusConditionsInner conditionsItem) {
    if (this.conditions == null) {
      this.conditions = new ArrayList<>();
    }
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * Get conditions
   * @return conditions
  **/
  @jakarta.annotation.Nullable
  public List<V1RayClusterSpecHeadGroupSpecHeadServiceStatusConditionsInner> getConditions() {
    return conditions;
  }


  public void setConditions(List<V1RayClusterSpecHeadGroupSpecHeadServiceStatusConditionsInner> conditions) {
    this.conditions = conditions;
  }


  public V1RayClusterStatus desiredCPU(Object desiredCPU) {
    
    this.desiredCPU = desiredCPU;
    return this;
  }

   /**
   * Get desiredCPU
   * @return desiredCPU
  **/
  @jakarta.annotation.Nullable
  public Object getDesiredCPU() {
    return desiredCPU;
  }


  public void setDesiredCPU(Object desiredCPU) {
    this.desiredCPU = desiredCPU;
  }


  public V1RayClusterStatus desiredGPU(Object desiredGPU) {
    
    this.desiredGPU = desiredGPU;
    return this;
  }

   /**
   * Get desiredGPU
   * @return desiredGPU
  **/
  @jakarta.annotation.Nullable
  public Object getDesiredGPU() {
    return desiredGPU;
  }


  public void setDesiredGPU(Object desiredGPU) {
    this.desiredGPU = desiredGPU;
  }


  public V1RayClusterStatus desiredMemory(Object desiredMemory) {
    
    this.desiredMemory = desiredMemory;
    return this;
  }

   /**
   * Get desiredMemory
   * @return desiredMemory
  **/
  @jakarta.annotation.Nullable
  public Object getDesiredMemory() {
    return desiredMemory;
  }


  public void setDesiredMemory(Object desiredMemory) {
    this.desiredMemory = desiredMemory;
  }


  public V1RayClusterStatus desiredTPU(Object desiredTPU) {
    
    this.desiredTPU = desiredTPU;
    return this;
  }

   /**
   * Get desiredTPU
   * @return desiredTPU
  **/
  @jakarta.annotation.Nullable
  public Object getDesiredTPU() {
    return desiredTPU;
  }


  public void setDesiredTPU(Object desiredTPU) {
    this.desiredTPU = desiredTPU;
  }


  public V1RayClusterStatus desiredWorkerReplicas(Integer desiredWorkerReplicas) {
    
    this.desiredWorkerReplicas = desiredWorkerReplicas;
    return this;
  }

   /**
   * Get desiredWorkerReplicas
   * @return desiredWorkerReplicas
  **/
  @jakarta.annotation.Nullable
  public Integer getDesiredWorkerReplicas() {
    return desiredWorkerReplicas;
  }


  public void setDesiredWorkerReplicas(Integer desiredWorkerReplicas) {
    this.desiredWorkerReplicas = desiredWorkerReplicas;
  }


  public V1RayClusterStatus endpoints(Map<String, String> endpoints) {
    
    this.endpoints = endpoints;
    return this;
  }

  public V1RayClusterStatus putEndpointsItem(String key, String endpointsItem) {
    if (this.endpoints == null) {
      this.endpoints = new HashMap<>();
    }
    this.endpoints.put(key, endpointsItem);
    return this;
  }

   /**
   * Get endpoints
   * @return endpoints
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getEndpoints() {
    return endpoints;
  }


  public void setEndpoints(Map<String, String> endpoints) {
    this.endpoints = endpoints;
  }


  public V1RayClusterStatus head(V1RayClusterStatusHead head) {
    
    this.head = head;
    return this;
  }

   /**
   * Get head
   * @return head
  **/
  @jakarta.annotation.Nullable
  public V1RayClusterStatusHead getHead() {
    return head;
  }


  public void setHead(V1RayClusterStatusHead head) {
    this.head = head;
  }


  public V1RayClusterStatus lastUpdateTime(Object lastUpdateTime) {
    
    this.lastUpdateTime = lastUpdateTime;
    return this;
  }

   /**
   * Get lastUpdateTime
   * @return lastUpdateTime
  **/
  @jakarta.annotation.Nullable
  public Object getLastUpdateTime() {
    return lastUpdateTime;
  }


  public void setLastUpdateTime(Object lastUpdateTime) {
    this.lastUpdateTime = lastUpdateTime;
  }


  public V1RayClusterStatus maxWorkerReplicas(Integer maxWorkerReplicas) {
    
    this.maxWorkerReplicas = maxWorkerReplicas;
    return this;
  }

   /**
   * Get maxWorkerReplicas
   * @return maxWorkerReplicas
  **/
  @jakarta.annotation.Nullable
  public Integer getMaxWorkerReplicas() {
    return maxWorkerReplicas;
  }


  public void setMaxWorkerReplicas(Integer maxWorkerReplicas) {
    this.maxWorkerReplicas = maxWorkerReplicas;
  }


  public V1RayClusterStatus minWorkerReplicas(Integer minWorkerReplicas) {
    
    this.minWorkerReplicas = minWorkerReplicas;
    return this;
  }

   /**
   * Get minWorkerReplicas
   * @return minWorkerReplicas
  **/
  @jakarta.annotation.Nullable
  public Integer getMinWorkerReplicas() {
    return minWorkerReplicas;
  }


  public void setMinWorkerReplicas(Integer minWorkerReplicas) {
    this.minWorkerReplicas = minWorkerReplicas;
  }


  public V1RayClusterStatus observedGeneration(Long observedGeneration) {
    
    this.observedGeneration = observedGeneration;
    return this;
  }

   /**
   * Get observedGeneration
   * @return observedGeneration
  **/
  @jakarta.annotation.Nullable
  public Long getObservedGeneration() {
    return observedGeneration;
  }


  public void setObservedGeneration(Long observedGeneration) {
    this.observedGeneration = observedGeneration;
  }


  public V1RayClusterStatus readyWorkerReplicas(Integer readyWorkerReplicas) {
    
    this.readyWorkerReplicas = readyWorkerReplicas;
    return this;
  }

   /**
   * Get readyWorkerReplicas
   * @return readyWorkerReplicas
  **/
  @jakarta.annotation.Nullable
  public Integer getReadyWorkerReplicas() {
    return readyWorkerReplicas;
  }


  public void setReadyWorkerReplicas(Integer readyWorkerReplicas) {
    this.readyWorkerReplicas = readyWorkerReplicas;
  }


  public V1RayClusterStatus reason(String reason) {
    
    this.reason = reason;
    return this;
  }

   /**
   * Get reason
   * @return reason
  **/
  @jakarta.annotation.Nullable
  public String getReason() {
    return reason;
  }


  public void setReason(String reason) {
    this.reason = reason;
  }


  public V1RayClusterStatus state(String state) {
    
    this.state = state;
    return this;
  }

   /**
   * Get state
   * @return state
  **/
  @jakarta.annotation.Nullable
  public String getState() {
    return state;
  }


  public void setState(String state) {
    this.state = state;
  }


  public V1RayClusterStatus stateTransitionTimes(Map<String, OffsetDateTime> stateTransitionTimes) {
    
    this.stateTransitionTimes = stateTransitionTimes;
    return this;
  }

  public V1RayClusterStatus putStateTransitionTimesItem(String key, OffsetDateTime stateTransitionTimesItem) {
    if (this.stateTransitionTimes == null) {
      this.stateTransitionTimes = new HashMap<>();
    }
    this.stateTransitionTimes.put(key, stateTransitionTimesItem);
    return this;
  }

   /**
   * Get stateTransitionTimes
   * @return stateTransitionTimes
  **/
  @jakarta.annotation.Nullable
  public Map<String, OffsetDateTime> getStateTransitionTimes() {
    return stateTransitionTimes;
  }


  public void setStateTransitionTimes(Map<String, OffsetDateTime> stateTransitionTimes) {
    this.stateTransitionTimes = stateTransitionTimes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1RayClusterStatus v1RayClusterStatus = (V1RayClusterStatus) o;
    return Objects.equals(this.availableWorkerReplicas, v1RayClusterStatus.availableWorkerReplicas) &&
        Objects.equals(this.conditions, v1RayClusterStatus.conditions) &&
        Objects.equals(this.desiredCPU, v1RayClusterStatus.desiredCPU) &&
        Objects.equals(this.desiredGPU, v1RayClusterStatus.desiredGPU) &&
        Objects.equals(this.desiredMemory, v1RayClusterStatus.desiredMemory) &&
        Objects.equals(this.desiredTPU, v1RayClusterStatus.desiredTPU) &&
        Objects.equals(this.desiredWorkerReplicas, v1RayClusterStatus.desiredWorkerReplicas) &&
        Objects.equals(this.endpoints, v1RayClusterStatus.endpoints) &&
        Objects.equals(this.head, v1RayClusterStatus.head) &&
        Objects.equals(this.lastUpdateTime, v1RayClusterStatus.lastUpdateTime) &&
        Objects.equals(this.maxWorkerReplicas, v1RayClusterStatus.maxWorkerReplicas) &&
        Objects.equals(this.minWorkerReplicas, v1RayClusterStatus.minWorkerReplicas) &&
        Objects.equals(this.observedGeneration, v1RayClusterStatus.observedGeneration) &&
        Objects.equals(this.readyWorkerReplicas, v1RayClusterStatus.readyWorkerReplicas) &&
        Objects.equals(this.reason, v1RayClusterStatus.reason) &&
        Objects.equals(this.state, v1RayClusterStatus.state) &&
        Objects.equals(this.stateTransitionTimes, v1RayClusterStatus.stateTransitionTimes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availableWorkerReplicas, conditions, desiredCPU, desiredGPU, desiredMemory, desiredTPU, desiredWorkerReplicas, endpoints, head, lastUpdateTime, maxWorkerReplicas, minWorkerReplicas, observedGeneration, readyWorkerReplicas, reason, state, stateTransitionTimes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1RayClusterStatus {\n");
    sb.append("    availableWorkerReplicas: ").append(toIndentedString(availableWorkerReplicas)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    desiredCPU: ").append(toIndentedString(desiredCPU)).append("\n");
    sb.append("    desiredGPU: ").append(toIndentedString(desiredGPU)).append("\n");
    sb.append("    desiredMemory: ").append(toIndentedString(desiredMemory)).append("\n");
    sb.append("    desiredTPU: ").append(toIndentedString(desiredTPU)).append("\n");
    sb.append("    desiredWorkerReplicas: ").append(toIndentedString(desiredWorkerReplicas)).append("\n");
    sb.append("    endpoints: ").append(toIndentedString(endpoints)).append("\n");
    sb.append("    head: ").append(toIndentedString(head)).append("\n");
    sb.append("    lastUpdateTime: ").append(toIndentedString(lastUpdateTime)).append("\n");
    sb.append("    maxWorkerReplicas: ").append(toIndentedString(maxWorkerReplicas)).append("\n");
    sb.append("    minWorkerReplicas: ").append(toIndentedString(minWorkerReplicas)).append("\n");
    sb.append("    observedGeneration: ").append(toIndentedString(observedGeneration)).append("\n");
    sb.append("    readyWorkerReplicas: ").append(toIndentedString(readyWorkerReplicas)).append("\n");
    sb.append("    reason: ").append(toIndentedString(reason)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    stateTransitionTimes: ").append(toIndentedString(stateTransitionTimes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("availableWorkerReplicas");
    openapiFields.add("conditions");
    openapiFields.add("desiredCPU");
    openapiFields.add("desiredGPU");
    openapiFields.add("desiredMemory");
    openapiFields.add("desiredTPU");
    openapiFields.add("desiredWorkerReplicas");
    openapiFields.add("endpoints");
    openapiFields.add("head");
    openapiFields.add("lastUpdateTime");
    openapiFields.add("maxWorkerReplicas");
    openapiFields.add("minWorkerReplicas");
    openapiFields.add("observedGeneration");
    openapiFields.add("readyWorkerReplicas");
    openapiFields.add("reason");
    openapiFields.add("state");
    openapiFields.add("stateTransitionTimes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1RayClusterStatus
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1RayClusterStatus.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1RayClusterStatus is not found in the empty JSON string", V1RayClusterStatus.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1RayClusterStatus.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1RayClusterStatus` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if (jsonObj.get("conditions") != null && !jsonObj.get("conditions").isJsonNull()) {
        JsonArray jsonArrayconditions = jsonObj.getAsJsonArray("conditions");
        if (jsonArrayconditions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("conditions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `conditions` to be an array in the JSON string but got `%s`", jsonObj.get("conditions").toString()));
          }

          // validate the optional field `conditions` (array)
          for (int i = 0; i < jsonArrayconditions.size(); i++) {
            V1RayClusterSpecHeadGroupSpecHeadServiceStatusConditionsInner.validateJsonObject(jsonArrayconditions.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `head`
      if (jsonObj.get("head") != null && !jsonObj.get("head").isJsonNull()) {
        V1RayClusterStatusHead.validateJsonObject(jsonObj.getAsJsonObject("head"));
      }
      if ((jsonObj.get("reason") != null && !jsonObj.get("reason").isJsonNull()) && !jsonObj.get("reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reason").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1RayClusterStatus.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1RayClusterStatus' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1RayClusterStatus> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1RayClusterStatus.class));

       return (TypeAdapter<T>) new TypeAdapter<V1RayClusterStatus>() {
           @Override
           public void write(JsonWriter out, V1RayClusterStatus value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1RayClusterStatus read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1RayClusterStatus given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1RayClusterStatus
  * @throws IOException if the JSON string is invalid with respect to V1RayClusterStatus
  */
  public static V1RayClusterStatus fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, V1RayClusterStatus.class);
  }

 /**
  * Convert an instance of V1RayClusterStatus to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

